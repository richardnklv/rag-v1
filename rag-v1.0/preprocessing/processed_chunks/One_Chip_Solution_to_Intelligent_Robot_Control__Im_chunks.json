{
  "filename": "One_Chip_Solution_to_Intelligent_Robot_Control__Im.pdf",
  "text_length": 27051,
  "chunk_count": 11,
  "chunks": [
    "_Pashenkov, N & Iwamasa, R & Iwamasa, R / One-Chip Solution to Intelligent Robot Control: Implementing Hexapod_\n_Subsumption Architecture Using a Contemporary Microprocessor, pp 93 - 98, International Journal of_\n_Advanced Robotic Systems, Volume 1 Number 2 (2004), ISSN 1729-8806_\n\n# **One-Chip Solution to Intelligent Robot Control:** **Implementing Hexapod Subsumption Architecture** **Using a Contemporary Microprocessor**\n\n\n**Nikita Pashenkov & Ryuichi Iwamasa**\nGK Tech Inc ,\n3-30-14, Takada, Toshima-ku, Tokyo, 171-0033, Japan\ne-mail: nik@media mit edu, iwamasa@gk-design co jp\n\n\n_**Abstract:**_ _This paper introduces a six-legged autonomous robot managed by a single controller and a software core_\n_modeled on subsumption architecture We begin by discussing the features and capabilities of IsoPod, a new processor_\n_for robotics which has enabled a streamlined implementation of our project We argue that this processor offers a_\n_unique set of hardware and software features, making it a practical development platform for robotics in general and_\n_for subsumption-based control architectures in particular Next, we summarize original ideas on subsumption_\n_architecture implementation for a six-legged robot, as presented by its inventor Rodney Brooks in 1980’s A_\n_comparison is then made to a more recent example of a hexapod control architecture based on subsumption The merits_\n_of both systems are analyzed and a new subsumption architecture layout is formulated as a response We conclude with_\n_some remarks regarding the development of this project as a hint at new potentials for intelligent robot design, opened_\n_up by a recent development in embedded controller market _\n_**Keywords:**_ _subsumption architecture, hexapod, virtually_ _parallel architecture, IsoPod, IsoMax_\n\n\n\n**1 Introduction**\n\nAs a preliminary application area for the technology\nplatform of a robotics project, we have recently\nundertaken a task of implementing a controller\narchitecture for an autonomous six-legged robot The\nproject was spurred in part by the availability of a new\nembedded development board for robotics, called\n_IsoPod_, designed around a speedy general-purpose DSP\ncore and marketed by a small company in Texas, USA As the next section will attempt to show, the combined\nfeature set of the new processor makes it a uniquely\nconvenient platform for the development of software\ncontrollers from the simplest to very complex machines IsoPod’s on-chip operating system in particular is\ndesigned to encourage a modular approach to software\narchitecture design from bottom up As a complement to\nthis approach, we decided to implement a version of\nsubsumption architecture, popularized by Rodney A Brooks at MIT in 1980’s, as our software controller",
    "Brooks at MIT in 1980’s, as our software controller This paper discusses a short overview of two\nsubsumption architecture layouts for a six-legged robot The first scheme is Brooks’ original architecture for his\nseminal Gehghis hexapod (Brooks, R & Flynn, A ,\n1989) The second is a recent example of a subsumption\n\n\n\narchitecture developed as a response to and an\nimprovement upon Brooks’ in terms of clarity Our own\napproach led us to a new modification of hexapod\nsubsumption which draws on both of the previous\nexamples In conclusion, we discuss the details of our subsumption\ncontroller implementation as it relates to the specifics of\nour chosen development platform We believe that the\nappearance of advanced yet inexpensive robotics\nplatforms, such as IsoPod and its operating system\n_IsoMax_, open up new possibilities for the construction of\nintelligent robotics platforms by professionals and\nhobbyists alike **2 IsoPod Hardware**\n\nIsoPod™ is a controller board designed with robotics\napplications in mind by New Micros, Inc IsoPod Hardware**\n\nIsoPod™ is a controller board designed with robotics\napplications in mind by New Micros, Inc of Dallas,\nTexas of Dallas,\nTexas Introduced on June 2002, Isopod is marketed by\nthe company as a complete interactively programmable\nsystem, featuring a built-in high-level language and a\n“virtually-parallel processing” operating system,\nIsoMax™ The IsoPod hardware is based around a\nMotorola DSP56F800-series 16-bit Digital Signal\nProcess (DSP) processor, which runs at 80Mhz and\n\n\n93\n\n\n|Serial, Power & Ground, Reset, two 8-bit digital port connections 2x4-channel analog input servo, PWM, timers I/O & SPI|Col2|Col3|Col4|Col5|Col6|Col7|Col8|Col9|\n|---|---|---|---|---|---|---|---|---|\n||||||||||\n||**IsoPod**||||||||\n||**IsoPod**||||||||\n||**IsoPod**||||||||\n||||||||||\n\n\n\ndiagnostic LEDs JTAG RS-232/422/485 current &\nCAN BUS fault sense\n\n\nFig 1 IsoPod board and functional diagram provides a wealth of hardware features including 16\nGeneral Purpose Digital I/O lines, 2 serial channels, RS232 and RS-422/485, CAN BUS, an SPI Interface, 8\nchannels of 12-bit A/D, 8 General Purpose Timers, and\n12 PWM outputs Notably, the multitude of useful\nfeatures are brought out onto easy-to-access connectors\nthat are densely populated on the 1 2” x 3 0” IsoPod\nboard An additional small connector board is provided\nso that up to 22 servos could be connected to the IsoPod According to New Micros, the overall list of features\nmakes IsoPod hardware suitable for dedicated control of\nDC motors, BDCM, stepper motors, solenoids, and other\nbipolar outputs (New Micros, Inc , 2004) **3",
    "**3 IsoPod Software**\n\nIn addition to a solid set of hardware features provided\nby its powerful processor, IsoPod boasts an innovative\nsoftware foundation Each IsoPod ships pre-loaded with\na resident programming language IsoMax, which is\nbased on the notion of Finite State Machines (FSM) and\na procedural language derived from Forth The key\nfeature of IsoMax is the concept of Virtually Parallel\nMachine Architecture, billed by New Micros as a “new\nprogramming paradigm ” VPMA allows independent\nvirtual machines to be constructed in software, tested one\nby one and added seamlessly together, then run in a\nvirtually parallel fashion According to the maker, “The\nVPMA structure may hold advances in Neural Net\nProcessing simulation, and AI applications robots\nusing this new paradigm may appear more ‘thinking’\nthan their predecessors ”\n\n**4 IsoPod Programming**\n\nThe development of user programs for the IsoPod is\naccomplished via serial communication with the board\n\n\n94\n\n\n\nthrough RS-232 connection and a terminal program on a\nPC The programming process consists of loading\nsegments of programs into IsoPod RAM or Flash\nmemory, then testing them interactively by invoking\nappropriate commands Programming real time tasks in IsoMax consists of\ndescribing virtual machines that will sense conditions,\ntake actions, and move to new states IsoMax provides a\nconvenient syntax to create new processor tasks, each\nbeing a state machine, and the means of changing states\nin a machine A simple virtual machine can be\nconstructed with a few lines of code, then tested by\ncalling up the machine state and ‘installing’ the machine\nindividually or into a ‘chain’ of (theoretically unlimited)\nnumber of machines",
    "A simple virtual machine can be\nconstructed with a few lines of code, then tested by\ncalling up the machine state and ‘installing’ the machine\nindividually or into a ‘chain’ of (theoretically unlimited)\nnumber of machines The table in Fig 2 outlines the\nspecifics of IsoMax syntax as it relates to this process Between the standard clauses of IsoMax, procedural\nstatements modeled after Forth prog-ramming language\ncan be inserted These statements complement IsoMax to\nprovide a rich syntax, the structure of which resembles\nsomething of a cross between assembly code and a highlevel language Like the latter, the syntax of IsoMax is\nloose in regard to spacing and indentation The concept\nof virtually parallel machines also encourages a\nprogramming style more akin to the structure of more\nrecent object-oriented languages, in comparison to\nprocedural languages that are in fact closer\ncontemporaries of Forth **Step** **Programming Action** **Syntax**\n\n1 Name a state machine MACHINE <name>\n\n2 Select state ON-MACHINE <name>\n\n3 Name appended states APPEND-STATE <name>\n\n4 Describe state transitions:\n\nstarting state IN-STATE <state>\ncondition necessary to leave CONDITION <boolean>\naction to take place CAUSES <action>\nstate to go to next time THEN-STATE <state>\nclosing statement TO-HAPPEN\n\n5 Set state <state> SET-STATE\n\n6 Run machine INSTALL <machine>\n\nFig 2 IsoMax state machine syntax **5 IsoPod Evaluation**\n\nIn our tests so far, IsoPod has proven to be a mature and\ndependable product, although an occasional bug or lack\nof documented feature reveals that IsoMax operating\nsystem is still in beta release (version 0 6 as of this\nwriting) Of particular interest to this project are two\nmain features of the Isopod package Firstly, the fact that\na single IsoPod controller is able to control up to 22\nservos, a number suitable to construct a six-legged robot\nwith 3 degrees of freedom per leg Secondly, the fact that\nIsoPod software model is based on the concept of Finite\nState Machines and allows for easy construction and\ntesting of a multitude of such modules, which can run in\na virtually parallel fashion This feature makes IsoPod a\nnear-ideal testing bed for robot control systems based on\n\n\nthe idea subsumption architecture, described in more\ndetail below",
    "This feature makes IsoPod a\nnear-ideal testing bed for robot control systems based on\n\n\nthe idea subsumption architecture, described in more\ndetail below **6 Subsumption Architecture**\n\nSubsumption architecture was developed by Rodney A Brooks and his students at MIT Artificial Intelligence\nLaboratory in as the cornerstone of their “Nouvelle AI”\nphilosophy (Brooks, R (Brooks, R , 1986) The basic framework of\nsubsumption is a modular network of Finite State\nMachines, which can be broken into layers of control\nallowing the robot to operate at increasing levels of\n‘competence ’ The control layers are made up of\nasynchronous modules that communicate with each other\nby passing messages ’ The control layers are made up of\nasynchronous modules that communicate with each other\nby passing messages Fig 3 Generalized subsumption diagram The term ‘subsumption’ derives from the idea that higher\nlevels can subsume the lower levels by suppressing their\noutputs as needed The advantage of this system is that a\nrobot control systems can be built incrementally, as\nlower levels continue to function while higher ones are\nadded on The result, according to Brooks, is a\ndevelopment framework for robotics that offers a large\nnumber of advantages concerning robustness,\nbuildability, and testability over the approaches emplyed\nin traditional or classical AI (Brooks, R , 1990)\n\n**6 Hexapod Subsumption Architecture by Brooks**\n\nThe earliest description of subsumption architecture for a\nhexapod robot is provided by Brooks in MIT A I Laboratory Memo from 1989 Brooks gives a clear\nanalysis of the architecture layout in two parts The first\npart describes the lower portion of the entire architecture\nexcluding sensor feedback and some high-level behavior\nmodules As the principle of subsumption dictates, the\nlower portion of the diagram can function on its own to\nprovide a self-sufficient behavior, called ‘simple walk’ in\nthis case",
    "As the principle of subsumption dictates, the\nlower portion of the diagram can function on its own to\nprovide a self-sufficient behavior, called ‘simple walk’ in\nthis case (Brooks, R (Brooks, R , 1989)\n_Simple walk_ consists of 36 machines which together\nenable a six-legged robot to walk across flat terrain The\nlowest level of competence in this set consists of _alpha_\n_position_ and _beta position_ modules, which receive\nvariables controlling the positions of corresponding leg\nmotors or servos When the system is first powered up,\nthese machines are sent initial values that cause the robot\n\nto stand up Fig 4 Hexapod Subsumption by Brooks The addition of a few more machines allow the robot to\n\nmake a step The _leg down_ module for each leg always\ntries to set the corresponding limb to downward position\nby writing to the _beta position_ module This message can\nbe suppressed by the _up leg trigger_ machine, causing the\nrobot to raise the leg when activated Once the output of\n_beta position_ matches the desired height, _alpha advance_\nmachine is triggered, causing the robot’s leg to swing\nforward The global _alpha balance_ machine sums the\n_alpha position_ outputs of each leg and writes a small\ncounterbalancing value to inputs unsuppressed by aadvance As a result, whenever a robot leg moves\nforward, the other legs move slightly back (or vice versa)\nmaking a balanced step Finally, walking is achieved with the addition of _walk_\nmachine, which sends an appropriate pattern of _up leg_\n_trigger_ messages that propagate according to the\nsequence described above It is possible to make the\nrobot produce a number of walking patterns, from ripple\ngate (one leg at a time) to tripod gate (three legs at a\ntime), by changing the pattern stored in _walk_, without\nadjusting any of the modules below The diagram in Fig 4 represents the complete hexapod\nsubsumption architecture designed by Brooks The extra\nmodules added on top of _simple walk_ allow the robot to\nsense its environment and to be able to traverse uneven\n\nterrain In order for the robot to sense contact with the\n\nground, _beta force_ module is provided A global _beta_\n_balance_ module corrects the vertical displacement of all\nlegs so that the robot maintains a stable position On the\nhorizontal plane, _alpha collide_ module monitors any\nlateral forces on robot’s legs that may come from\nobstacles, causing the legs to lift to overcome them Since the robot is outfitted with whiskers, _feeler_ module\nis added which helps the robot to anticipate obstacles\nlying ahead Finally, the high-level _prowl_ behavior\nmodule is added which receives input from _IR sensor_\nmodule This unit is programmed such that when motion\nis detected by the sensors, the walking behavior is\nactivated causing the robot to wander The full-featured Brooks’ subsumption architecture as\ndescribed above proved itself successful in real-world\ntests on robots built at MIT However, a quick look at\nthe diagram reveals a rather complicated patchwork of\nmodules that has lost some of the elegance of the original\n_simple walk_ A more recent example of hexapod\nsubsumption architecture tackles this issue in an attempt\nto provide a more clear and easy-to-read diagram",
    "A more recent example of hexapod\nsubsumption architecture tackles this issue in an attempt\nto provide a more clear and easy-to-read diagram 95\n\n\n**7 95\n\n\n**7 Contemporary Example of Hexapod Subsumption**\n**Architecture**\n\nIn 2000, Enric Celaya and Josep M Porta of Institut de\nCibernètica, Barcelona, developed a controller for a sixlegged robot that allows it to walk on rough terrain using\nforce feedback (Celaya, E & Porta, J & Porta, J , 2000) The\nresearchers suggest that their initial approach was to add\na force-compliance layer on top of a subsumption-based\ncontroller tailored to walk on flat surfaces and thus build\nthe controller in a purely incremental way However,\nPorta & Celaya found that they needed to make\nsubstantial modications to the existing layers first For example, the previously described _walk_ and _alpha_\n_advance_ behaviors had to be redesigned or completely\neliminated In addition, modularity of the architecture\nwas lost as layered structure had to be defined differently\nfor compliant (force-feedback) and non-compliant\n( _simple walk_ ) versions A solution to these problems was\nfound by redesigning the layer structure of Brooks’\narchitecture by moving the balance and compliance layer\nbelow walking and other high-level behaviors According to Porta & Celaya, the resulting organization\nachieved a clear and natural new subsumption\nbreakdown and solved problems with modularity and\nincrementality Brooks’ diagram As the authors themselves note,\n“keeping feet and maintaining stability is more\nfundamental than advancing ”\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFig 5 Subsumption Diagram by Porta & Celaya The diagram above represents the subsumption\narchitecture developed by Porta & Celaya The layout\nshows that some of the simpler modules, such as _alpha_\n_collide_ and _up leg trigger_ have been encapsulated into\nthe _step_ and _skip_ modules, and _beta balance_ has been\nmoved to a lower level according to the new competence\nbreakdown The diagram also introduces new modules\nthat are meant to resolve the situation when two or more\nsuppressing signals are connected to the same input To\nestablish priority levels between these, the motor\ninterface is now split into two behaviors, _alpha move_ and\n_alpha motor_, each with its own supressing signal Overall, the new subsumption architecture by Porta &\nCelaya offers a great improvement over Brooks’ in terms\nof clarity In particular, the fact that the _beta balance_\nmodule is now located at the same low hierarchical level\nas its counterpart _alpha balance_ is a more elegant\nsolution than the high-level placement of this module in\n\n\n96\n\n\n\nFig",
    "In particular, the fact that the _beta balance_\nmodule is now located at the same low hierarchical level\nas its counterpart _alpha balance_ is a more elegant\nsolution than the high-level placement of this module in\n\n\n96\n\n\n\nFig 6 Our Subsumption Diagram **8 Our Subsumption Architecture**\n\nThe design approach taken by Porta & Celaya was to\nstart with Brooks’ example and to improve upon it by\nreorganizing the competence layer structure into a more\nintuitive diagram However, we feel that Porta &\nCelaya’s architecture could be clarified further The\nmotor interface modules in particular seem like a\npeculiar patch that is needed in order to resolve a conflict\nbetween higher level machines rather than fulfill a\nnecessary function This flaw encouraged us to seek a\nslight modification to the subsumption architecture\nmodel for our robot The starting point of our subsumption scheme is identical\nto Brooks’ _simple walk_ Next, we add _beta balance_\nmachine at the bottom layer of the diagram This\nplacement is crucial in re-organization of subsumption\nmodules in that it creates a mirroring of two behavior\nblocks in the horizontal and vertical direction at the same\n\ncompetence level Following this example, our original intention was to add\n_alpha back_ machine above the _alpha forward_ module\n( _alpha advance_ in Brooks) as a mirror of the vertical\nmovement machine set However, there is a difference in\nwhich the horizontal and vertical sets operate The\ndefault vertical orientation of the robot is to be standing\nup, dictating that the _beta down_ machines are constantly\nactivated On the other hand, there is no default position\nfor the horizontal leg movement and thus we see no need\nfor a breakdown of this component in two halves and use\na single machine _alpha move_ instead It is notable that we keep both _beta up_ and _beta down_\nsubsumption modules as they provide the basic\nfunctionality of moving the robot legs vertically In\ncontrast, Porta & Celaya retain _beta down_ machine\n(renamed _land_ ) but eliminate _beta up_ as a standalone\nmodule, presumably encapsulating its functionality into\n_skip_ and _step_ modules Our architecture contains both of\nthese machines as well, but in comparison to Porta &\nCelaya’s they feature a reduced set of internal states\n\n\nwhich take care of higher-level functions and\ncommunicate with the already existing modules for\nlower-level tasks For example, _skip_ contains only the states invoked when\na leg encounters an obstacle while moving horizontally This condition causes _step_ to activate _beta up_ in order to\nmove the robot leg higher Accordingly, this module is\npositioned in the diagram right above and suppresses the\noutput of _step_ Next, the vertical and horizontal force (or\ntouch) sensors are placed on the left side of the diagram The walking sequence module, which has the internal\nstructure of Brooks’ _walk_, completes the layout of our\nsubsumption diagram We believe that the resulting layout, though not\nfunctionally very different from the model proposed by\nPorta & Celaya, offers a more clear picture of the\nsystem’s innerworkings Perhaps the main advantage is\nthat a slight rearrangement of higher-level modules\nallows us to avoid the ‘ambiguous’ condition of two\nmachines ( _skip_ and _step_ ) competing to suppress the\noutput of one lower one ( _alpha balance_ ) As a result, the\nplaceholder machines _alpha move_ and _beta move_ are\neliminated Our diagram retains the clear visual breakdown of\nmachine blocks into vertical levels of competence, as in\nPorta & Celaya In addition, it offers a clear horizontal\nbreakdown of machine blocks into functional categories\nthat could be loosely labeled as horizontal and vertical\nmovement control blocks, higher-level behavior blocks,\nand sensor input blocks To sum up, we have attempted\nto draft a two-dimensional diagram that complements the\nactual subsumption architecture as a structure that is\nfunctional and easy to read",
    "To sum up, we have attempted\nto draft a two-dimensional diagram that complements the\nactual subsumption architecture as a structure that is\nfunctional and easy to read **9 Implementation Details**\n\nSubsumption architecture is in essence a modular\nnetwork of finite state machines, each designed to work\non a specific behavioral task at hand IsoPod’s\nprogramming language IsoMax provides a means to\nimplement this type of architecture using a specially\ndesigned syntax Fig 2 in the earlier section provided an\noutline of how a finite state machine is constructed in\n\nIsoMax Our subsumption architecture consisted of\nsome 130+ finite state machines programmed in this\nfashion Our subsumption architecture consisted of\nsome 130+ finite state machines programmed in this\nfashion Fig 7 shows a graph representation of a typical\nsubsumption module in our diagram The Finite Machine\nstates are represented as circles and transitions between\nthem are indicated by arrows On the outside of each\narrow, a conditional statement is printed which allows\nthe machine to pass from one state to another when\nfulfilled On the inside, an action that takes place with a\ncorresponding state change is indicated The corners of\nthe state machine contain the inputs and outputs of the\nmodule that correspond directly to the arrow paths of the\nsubsumption architecture diagram The final breakdown of the subsumption architecture\nmodule into its representation in programmer’s code is\nshown in Fig 8 |Col1|Col2|\n|---|---|\n|_BPOS IN_|_BPOS IN_|\n|_BPOS IN_||\n\n\n\nFig 7 Graph representation of our _beta down_ FSM MACHINE L1-BETA-DOWN EEWORD\n\nON-MACHINE L1-BETA-DOWN\n\nAPPEND-STATE L1-BETA-DOWN-UP EEWORD\n\nAPPEND-STATE L1-BETA-DOWN-DWN EEWORD\n\n\nIN-STATE\n\nL1-BETA-DOWN-UP\n\nCONDITION\n\nL1 BPOS OUT @ BPOS MAXDWN @ >\n\nL1 LEGDWN SUP @ NOT AND\n\nL1 BFORCE @ < BFORCE MAX @ AND\n\nCAUSES\n\nBPOS MAXDWN @ L1 BPOS IN THEN-STATE\n\nL1-BETA-DOWN-DWN\n\nTO-HAPPEN IN-EE\n\n\nIN-STATE\n\nL1-BETA-DOWN-DWN\n\nCONDITION\n\nL1 BPOS OUT @ BPOS MAXDWN @ =\n\nCAUSES\n\nL1 BUP IN @ L1 BPOS IN THEN-STATE\n\nL1-BETA-DOWN-UP\n\nTO-HAPPEN IN-EE\n\nFig 8 A partial code equivalent of _beta down_ FSM The code snippet contains the same albeit abbreviated\nvariables, state definitions and conditional statements as\nthe graph diagram above As it is evident, IsoMax\nprovides a very convenient syntax for defining virtual\nmachines like this, naming the states of the machine and\nidentifying transitions between states As a result, the\nrelationship between the graph representation and code is\nvery direct and it is literally possible to debug a program\nby carefully drawing and studying its corresponding\ndiagram",
    "As a result, the\nrelationship between the graph representation and code is\nvery direct and it is literally possible to debug a program\nby carefully drawing and studying its corresponding\ndiagram **10 Results**\n\nIsoPod's Virtually Parallel Machine Architecture appears\nto provide an excellent platform for implementing a\nmodular control framework for robotics The goal of our\nproject was to test this hypothesis on a real-world\nexample by programming a subsumption-based behavior\narchitecture Our tests were carried out on a pre-fabricated kit robot\n“Hexapod III”, manufactured by Lynxmotion, Inc Our tests were carried out on a pre-fabricated kit robot\n“Hexapod III”, manufactured by Lynxmotion, Inc in\nU S A The robot chassis is lasercut from sheets of black\n\nlexan and comes with a set of injection molded nuts and\nbolts The photo below shows the constructed hexapod,\nwhich measures about 10” x 12” x 1 5” and has a ground\nclearance of about 5 inches Each of robot's legs has 3\n\n\n97\n\n\n\n\n\n\n\n\n\n\ndegrees of freedom, and it is powered by 18 Hitec HS85BB servos (Lynxmotion, Inc , 2003)\n\n\nFig 9 Hexapod III kit constructed and wired The IsoPod board is mounted inside the robot's body and\nprovides direct connections for each servo via a small\nadapter board The power supplies for IsoPod and servos\nare tethered to the robot A serial connection is used to\nupload programs to IsoPod hardware using a 115,600kbs\nconnection A serial connection is used to\nupload programs to IsoPod hardware using a 115,600kbs\nconnection Although our tests of the entire subsumption architecture\nare still preliminary at this stage, it was sufficient to\nmake the robot walk autonomously using a number of\npre-programmed gaits, sense small obstacles and step\nover them, and to stop and reverse motion at a cliff Predictably, the main problems we experienced were not\nwith the software architecture but hardware\n\nimperfections For instance, since we used a simple\ncurrent sensing method of measuring voltage drop across\na resistor, contact with ground by force-feedback became\ndifficult to manage (the robot tended to raise itself\ngradually due to constant _beta down_ ouput) and we opted\nfor digital contact sensors on feet instead Hexapod III\nalso had trouble maintaining its posture occasionally due\nto the choice of small-size servo motors Our overall\n\nimpression, however, was that we were able to design a\ncomplex modular control architecture using inexpensive,\noff-the-shelf parts in a very short time",
    "Our overall\n\nimpression, however, was that we were able to design a\ncomplex modular control architecture using inexpensive,\noff-the-shelf parts in a very short time **11 Conclusion**\n\nAt the time of Brooks’ first papers on subsumption, a\nmodular control architecture for a mobile robot could\n\nonly be implemented with independent processors which\nsent messages to each other over connecting wires Each\nprocessor in these original designs was itself a finite state\nmachine For example, the first walking robot built by\nBrooks had four onboard 8-bit microprocessors linked by\n62 5Kbaud token ring, offering a total memory of about\n1Kbyte of RAM and 10K of EPROM (Brooks, R (Brooks, R , 1989)\nThe current state of hardware development allows a\nmuch greater flexibility in the design and much faster\nspeed of system development One powerful processor\nwith a large cache of on-board memory and peripherals\n\n\n98\n\n\n\ncan replace a whole network of finite state machines and\nenable an entire subsumption architecture to be\nconstructed in software The IsoPod/IsoMax\n\ndevelopment platform is particularly well suited to this\ntask as its architecture is based very directly on the\nconcept of Finite State Machines running in parallel Our own preliminary progress presented here\ndemonstrates the feasibility of a quick cycle of\ndevelopment for a complex modular control system of an\nautonomous robot Our primary interest has not been to\nadvance the state of technology in robotics, but to\nsuggest that the task of implementing advanced robot\ncontrol architectures is becoming inexpensive and\naccessible We hope that this study will lead to\nincorporation of such systems into our future projects\nand encourage more experimentation in this realm by\nengineers, students and hobbyists **6 References**\n\nBrooks, R (1985) “Robust Layered Control System for a\nMobile Robot”, _MIT A I Memo 864_\nBrooks, R (1989) “A Robot that Walks; Emergent\nBehaviors from a Carefully Evolved Network”, _MIT_\n_A I Memo 1091_\nBrooks, R (1990) “Elephants Don’t Play Chess”,\n_Robotics and Autonomous Systems 6_, pp3-15\nBrooks, R & Flynn, A , (1989) “Fast, Cheap and Out of\nControl: A Robot Invasion of the Solar System”,\n_Journal of The British Interplanetary Society_, Vol 42, pp 478-485\nLynxmotion, Inc , _Hexapod III_\nhttp://lynxmotion com, Accessed: 2004-05-17\nNew Micros, Inc , _IsoPod, IsoMax_\nhttp://newmicros com, http://www isopod net,\nAccessed: 2004-05-17\n\nPorta, J & Celaya, E (2000) “Force-Based Control of a\nSix-Legged Robot on an Abrupt Terrain”, Institut de\nCibernètica, Barcelona, Spain,\npapers available from:\nhttp://www (2000) “Force-Based Control of a\nSix-Legged Robot on an Abrupt Terrain”, Institut de\nCibernètica, Barcelona, Spain,\npapers available from:\nhttp://www ee pdx edu/~mperkows/ML_LAB/Giant_\nHexapod/, Accessed: 2004-05-17"
  ]
}