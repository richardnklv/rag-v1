{
  "filename": "Iterative_MILP_Methods_for_Vehicle_Control_Problem.pdf",
  "text_length": 49645,
  "chunk_count": 10,
  "chunks": [
    "## Iterative MILP Methods for Vehicle Control Problems\n\nMatthew Earl [∗] and Raffaello D’Andrea\n\n\nAbstract\n\n\nMixed integer linear programming (MILP) is a powerful tool for planning and control problems because of its modeling capability and the availability of good solvers However, for large models, MILP methods suffer\ncomputationally In this paper, we present iterative MILP algorithms\nthat address this issue We consider trajectory generation problems with\nobstacle avoidance requirements and minimum time trajectory generation\nproblems The algorithms use fewer binary variables than standard MILP\nmethods and require less computational effort ### 1 Introduction\n\n\nMixed integer linear programming (MILP) methods have attracted attention\nbecause of their modeling capability and because powerful solvers are available\ncommercially The utilization of MILP for modeling and control problems is\ndescribed in [2] and for hybrid systems and practical applications in [17] MILP\nmethods are used in [19] for cooperative reconnaissance, in [20] for spacecraft\npath planning, and in [1, 10, 11] for cooperative control problems Powerful software packages such as CPLEX [15] solve MILPs efficiently for\nproblems in which the number of binary variables is of reasonable size However, a major disadvantage of MILP is its computational complexity Because\nMILP is NP-hard in the number of binary variables used in the problem formulation [14], computational requirements grow significantly as the number of\nbinary variables needed to model the problem increases Motivated to generate efficient MILP problem formulations, we have developed several iterative\ntechniques that require fewer binary variables than standard MILP methods The MILP obstacle avoidance methods from [20] and those from [10, 11],\ndeveloped independently, specify a uniformly distributed set of discrete times\nat which obstacle avoidance is enforced We call this approach uniform gridding In this approach, there is no avoidance guarantee between time steps In addition, many of the avoidance times are unnecessary, resulting in large\nMILPs that require a significant computational effort to solve Here, we present\n\n\n∗ Corresponding author email: mge1@cornell edu\n\n\n1\n\n\nan iterative MILP obstacle avoidance algorithm that can be used alone or in\ncombination with the uniform gridding approach The algorithm guarantees\nobstacle avoidance over the entire trajectory and distributes avoidance times efficiently, resulting in smaller MILPs that can be solved faster We also present\nan iterative MILP obstacle growing algorithm that allows the use of a coarse set\nof uniformly distributed obstacle avoidance times In this approach, collision\nfree trajectories are found by artificially increasing the size of the obstacles that\ncollide with the trajectory generated by the MILP, iterating until the resulting\ntrajectory is collision free Next, we consider the minimum time trajectory generation problem using\nMILP The MILP approach to this problem presented in [21, 22] generates an\napproximate solution Time is discretized uniformly, and an auxiliary binary\nvariable and a set of inequality constraints are added for each discrete time This\napproach gives an estimate to the time optimal solution that depends on the\nsampling time chosen For more accuracy, the sampling time is reduced, which\nresults in a larger number of binary variables in the MILP formulation and\nthus increases the computation time, possibly exponentially Here, we present\nan iterative MILP algorithm that solves for the time optimal solution to the\nproblem The algorithm uses binary search At each iteration, the feasibility of\na MILP with only one discrete time (for the minimum time part of the problem)\nneeds to be determined The paper is organized as follows: In Section 2, we describe the dynamics\nof the vehicles we use to motivate our methods In Section 3, we describe two\niterative MILP algorithms for obstacle avoidance, and we perform an average\ncase computational complexity study comparing the performance of the iterative\ntime step selection algorithm with the uniform gridding approach Finally, in\nSection 4, we describe an iterative MILP algorithm for minimum time control\nproblems All files for generating the plots found in this paper are available\nonline [12] ### 2 Vehicle dynamics\n\n\nWe motivate our methods using the wheeled robots of Cornell’s RoboCup Team [5,\n23] In this section, we show how to simplify their nonlinear governing equations\nusing a procedure from [18] The result is a linear set of governing equations\ncoupled by a nonlinear constraint on the control input This procedure allows\nreal-time calculation of many near-optimal trajectories and is a major factor\nfor Cornell’s success in the RoboCup competition We then show how to represent the simplified system in a MILP problem formulation The result is a set\nof linear discrete time governing equations subject to a set of linear inequality\nconstraints Each vehicle is equipped with a three-motor omni-directional drive, which\nallows it to move along any direction irrespective of its orientation This allows superior maneuverability compared to traditional nonholonomic (car-like)\n\n\n2\n\n\nvehicles The nondimensional governing equations of each vehicle are given by\n\n\nx¨(t) x˙ (t)\n\n¨ ˙\n\n   \n\n\n\n\n\n\n\nx¨(t)\n\n¨\n\n yθ¨((tt))\n\n\n\n\n\n\n\n+\n\n\n\n\nx˙ (t)\n\n˙\n\n y(t)\n\n2mL [2] ˙\n I θ\n\n\n\n\n\n\n\nI θ˙(t)\n\n\n\n= u(θ(t), t), (1)\n\n\n\n\nwhere u(θ(t), t) = P(θ(t))U(t),\n\n\n\nsin(θ) − sin( [π] 3 [−] [θ][)] sin( [π] 3 [+][ θ][)]\n\ncos(θ) − cos( [π] [−] [θ][)] − cos( [π] [+][ θ]\n\n\n\nθ) − cos( [π] 3 [−] [θ][)] − cos( [π] 3 [+][ θ][)]\n\n1 1 1\n\n\n\n\n[π] 3 [−] [θ][)] − cos( [π] 3\n\n\n\n\n[π] 3 [−] [θ][)] sin( [π] 3\n\n\n\n\n\n,\n\n\n\nP(θ) =\n\n\n\n\n\n\n\n− sin(θ) − sin( [π] 3\n\n cos(θ) − cos( [π] 3\n\n1 1\n\n\n\n\n\nand U(t) = (U 1 (t), U 2 (t), U 3 (t)) ∈U In these equations (x(t), y(t)) are the\ncoordinates of the vehicle, θ(t) is its orientation, u(θ(t), t) is the θ(t)-dependent\ncontrol input, m is the mass of the vehicle, I is its moment of inertia, L is the\ndistance from the drive to the center of mass, and U i (t) is the voltage applied\nto motor i The set of admissible voltages U is the unit cube, and the set of\nadmissible control inputs is given by P (θ)U These governing equations are coupled and nonlinear To simplify them,\nwe replace the set P (θ)U with the maximal θ-independent set found by taking\nthe intersection of all possible sets of admissible controls The result is a θindependent control set defined by control input (u x (t), u y (t), u θ (t)) and the\ninequality constraints u x (t) [2] + u y (t) [2] ≤ (3 −|u θ (t)|) [2] /4 and |u θ (t)| ≤ 3 Using\nthe restricted set as the allowable control set, the governing equations decouple\nand are given by\n\n\nx¨(t) x˙ (t) u x (t)\n\n¨ ˙\n\n     \n\n\n\n\n\n\n\nx¨(t)\n\n¨\n\n yθ¨((tt))\n\n\n\n\n\n\n\n+\n\n\n\n\n (2)\n\n\n\n\nx˙ (t)\n\n˙\n\n 2mL y( [2] t)˙\n\n I θ\n\n\n\n\n\n\n\nI θ˙(t)\n\n\n\n\n\n\n\n uu xy ((tt))\n\n u θ (t)\n\n\n\n =\n\n\n\nThe constraints on the control input couple the degrees of freedom To decouple the θ dynamics we further restrict the admissible control set to\na cylinder defined by the following two inequalities: |u θ (t)| ≤ 1 and\n\n\nu x (t) [2] + u y (t) [2] ≤ 1 (3)\n\n\nNow, the equations of motion for the translational dynamics of the vehicle are\ngiven by\n\n\nx¨(t) + ˙x(t) = u x (t),\n\ny¨(t) + ˙y(t) = u y (t), (4)\n\n\nsubject to equation (3) In state space form, equation (4) is ˙x(t) = A c x(t) +\nB c u(t), where x = (x, y, ˙x, ˙y) is the state and u = (u x, u y ) is the control input To represent the governing equations in a MILP framework, we discretize\nthe control input in time We require the control input be constant between\ntime steps The result is a set of linear discrete time governing equations, which\nwe derive next 3\n\n\nLet N u be the number of discretization steps for the control input u(t) Let\nt u [k] be the time at step k Let T u [k] > 0 be the time between steps k and k +1,\nfor k ∈{0, , N u − 1} The discrete time governing equations are given by\n\n\nx u [k + 1] = A[k]x u [k] + B[k]u[k], (5)\n\n\nwhere x u [k] = x(t u [k]), u[k] = u(t u [k]), x u [k] = (x u [k], y u [k], ˙x u [k], ˙y u [k]), and\nu[k] = (u x [k], u y [k]) The coefficients A[k] and B[k] are functions of k because\nwe have allowed for nonuniform time discretizations They can be calculated\nexplicitly in the usual way [8] Because there will be several different time\ndiscretizations used in this paper, we use subscripts to differentiate them In\nthis section, we use the subscript u to denote variables associated with the\ndiscretization in the control input u(t) The discrete time governing equations can be solved explicitly in the usual\nway [8] In later sections of this paper, it will be necessary to represent the\nposition of the vehicle, at times between control discretization steps, in terms\nof the control input Because the set of governing equations is linear, given the\ndiscrete state x u [k] and the control input u[k], we can calculate the vehicle’s\nstate at any time t using the following equations:\n\n\nx(t) = x u [k] + (1 − e [t] [u] [[][k][]][−][t] ) ˙x u [k]\n+ (t − t u [k] − 1 + e [t] [u] [[][k][]][−][t] )u x [k],\n\n\n˙\nx(t) = (e [t] [u] [[][k][]][−][t] ) ˙x u [k] + (1 − e [t] [u] [[][k][]][−][t] )u x [k], (6)\n\n\nwhere k satisfies t u [k] ≤ t ≤ t u [k + 1] If the time discretization of the control\ninput is uniform, T u [k u ] = T u for all k u, then k u = ⌊t/T u ⌋ The components of\nthe vehicle’s state, y(t) and ˙y(t), can be calculated in a similar way The control input constraint given by equation (3) cannot be expressed in\na MILP framework because it is nonlinear To incorporate this constraint, we\napproximate it with a set of linear inequalities that define a polygon The\npolygon inscribes the region defined by the nonlinear constraint We take the\nconservative inscribing polygon to guarantee that the set of allowable controls\ndefined by the region is feasible Similar to work in [21], we define the polygon\nby the set of M u linear inequality constraints\n\n\n\n\n[πm]\n\nM u + u y [k] cos [2] M [πm] u\n\n\n\nu x [k] sin [2][πm]\n\n\n\n\n[πm] ≤ cos [π]\n\nM u M\n\n\n\nM u M u M u\n\n∀m ∈{1, , M u }, (7)\n\n\n\nfor each step k ∈{1, , N u }",
    ", N u } To illustrate the approach, consider the following minimum control effort trajectory generation problem Given a vehicle governed by equations (5) and (7),\nfind the sequence of control inputs {u[k]} k [N] =0 [u] [−][1] that transfers the vehicle from\nstarting state x(0) = x s to finishing state x(t f ) = x f and minimizes the cost\nfunction\n\n\n\nJ =\n\n\n\nN u −1\n� (|u x [k]| + |u y [k]|) (8)\n\n\nk=0\n\n\n4\n\n\nTo convert the absolute values in the cost function to linear form, we introduce auxiliary continuous variables z x [k] and z y [k] and the inequality constraints\n\n\n−z x [k] ≤ u x [k] ≤ z x [k]\n−z y [k] ≤ u y [k] ≤ z y [k] (9)\n\n\nMinimizing z x [k] subject to the inequalities u x [k] ≤ z x [k] and u x [k] ≥−z x [k] is\nequivalent to minimizing |u x [k]| (similarly for |u y [k]|) [3] Using the auxiliary\nvariables, the cost function can be written as a linear function,\n\n\n\nJ =\n\n\n\nN u −1\n� (z x [k] + z y [k]) (10)\n\n\nk=0\n\n\n\nThe resulting optimization problem (minimize (10) subject to (5), (7), (9),\nand the boundary conditions) is in MILP form Because binary variables do not\nappear in the problem formulation, it is a linear program and is easily solved to\nobtain the optimal sequence of control inputs ### 3 Obstacle avoidance\n\n\nIn vehicle control, it is necessary to avoid other vehicles, stationary and moving\nobstacles, and restricted regions In this section, we show how to use MILP\nto solve obstacle avoidance problems, we present two iterative MILP obstacle avoidance algorithms that are more computationally efficient than standard\nmethods, and we perform an average case computational complexity study 3 1 MILP formulation\n\n\nWe start by showing a MILP method to guarantee circular obstacle avoidance\nat N o discrete times A version of this method for uniformly distributed obstacle avoidance times is presented in [20], and a similar method is presented\nindependently in [10, 11] The method we present here allows nonuniform distributions of obstacle avoidance times [8], which we take advantage of in our\niterative algorithm presented in the next section We use subscript o to denote\nvariables associated with the time discretization for obstacle avoidance For\nstep k, taken to be an element of the set {1, , N o }, let t o [k] be the time at\nwhich obstacle avoidance is enforced Let R obst denote the radius of the obstacle, and let (x obst [k], y obst [k]) denote the coordinates of its center at time t o [k] We approximate the obstacle with a polygon, denoted O[k], defined by a set of\nM o inequalities The polygon is given by\n\n\n\nO[k] = { (¯x, ¯y) : (¯x − x obst [k]) sin [2][πm]\n\n\n\nM o\n+ (¯y − y obst [k]) cos [2][πm] [≤] [R] [obst] [,]\n\n\n\n\n[πm]\n+ (¯y − y obst [k]) cos M o [≤] [R] [obst] [,] (11)\n\n∀m ∈{1, , M o } } 5\n\n\nTo guarantee obstacle avoidance at time t o [k] the coordinates of the vehicle\nmust be outside the region O[k] This avoidance condition can be written as\n(x o [k], y o [k]) /∈O[k], where (x o [k], y o [k]) are the coordinates of the vehicle at\ntime t o [k] Here x o [k] = x(t o [k]) and y o [k] = y(t o [k]) are expressed in terms of\nthe control inputs using equation (6) Because at least one constraint defining the region O[k] must be violated\nin order to avoid the obstacle, the avoidance condition is equivalent to the\nfollowing condition: there exists an m such that (x o [k] − x obst [k]) sin [2] M [πm] o [+]\n\n(y o [To express this avoidance constraint in a MILP problem formulation, itk] − y obst [k]) cos [2] M [πm] o [> R] [obst] [ ]\n\nmust be converted to an equivalent set of linear inequality constraints We do\nso by introducing auxiliary binary variable b m [k] ∈{0, 1} and the following M o\ninequality constraints:\n\n\n\n(x o [k] − x obst [k]) sin [2] M [πm]\n\n\n\n\n[πm]\n\nM o [+ (][y] [o] [[][k][]][ −] [y] [obst] [[][k][]) cos] [ 2] M [πm] o\n\n\n\nM o [o] M o\n\n(12)\n\n- R obst − Hb m [k], ∀m ∈{1, , M o },\n\n\n\nwhere H is a large positive number taken to be larger than the maximum dimension of the vehicle’s operating environment plus the radius of the obstacle If b m [k] = 1, the right side of the inequality is a large, negative number that\nis always less than the left side In this case, the inequality is inactive because\nit is trivially satisfied If b m [k] = 0, the inequality is said to be active because\nit reduces to an inequality from the existence condition above For obstacle\navoidance, at least one of the constraints in equation (12) must be active To\nenforce this, we introduce the following inequality constraint into the problem\nformulation:\n\n\nM o\n� b m [k] ≤ M o − 1 (13)\n\n\nm=1\n\n\nTherefore, to enforce obstacle avoidance at time t o [k], the set of binary\nvariables {b m [k]} [M] m=1 [o] [and the constraints given by equations (12) and (13) are]\nadded to the MILP problem formulation Consider the example problem from Section 2, adding obstacles that must\nbe avoided In this problem, we want to transfer the vehicle from start state x s\nto finish state x f in time t f using minimal control effort and avoiding obstacles To enforce obstacle avoidance at each time in the set {t o [k]} [N] k=1 [o] [, we augment]\nthe MILP formulation in Section 2 with the set of binary variables {b m [k]} [M] m=1 [o] [,]\nconstraints (12), and constraint (13) for all k in the set {1, , N o }",
    ", N o } Distributing the avoidance times uniformly (uniform gridding) results in a\ntrajectory that avoids obstacles at each discrete time in the set However, the\ntrajectory can collide with obstacles between avoidance times This is shown\nfor an example instance in Figure 1(a) A simple method to reduce this behavior is to take a finer discretization,\nwhich increases the number avoidance times, as shown in Figure 1(b) However,\nthis is not desirable in MILP because an increase in the number of avoidance\n\ntimes increases the number of binary variables in the problem However,\nthis is not desirable in MILP because an increase in the number of avoidance\n\ntimes increases the number of binary variables in the problem 6\n\n\n0 4\n\n\n0 2\n\n\n0\n\n\n−0 2\n\n\n0 4\n\n\n0 2\n\n\n0\n\n\n−0 2\n\n\n0 4\n\n\n0 2\n\n\n0\n\n\n−0 2\n\n\n\n(a)\n\n\n−0 5 0 0 5\n\n(b)\n\n\n−0 5 0 0 5\n\n(c)\n\n\n−0 5 0 0 5\n\n\n\nFigure 1: Figure (a) shows the resulting trajectory using uniform gridding (N o =\n10), Figure (b) shows the trajectory using a finer uniform gridding (N o = 50),\nand Figure (c) shows the trajectory using iterative MILP avoidance (N o = 9) The circles denote obstacles, and the polygons denote the buffer regions used in\nthe MILP formulation The values of the parameters are M o = 6, M u = 4, N u =\n4, (x s, y s, ˙x s, ˙y s ) = (−0 25, −0 2, −0 5, 0 3), and (x f, y f, ˙x f, ˙y f ) = (0 4, 0 3, 0, 0) 7\n\n\nTable 1: Iterative MILP time step selection algorithm\n\n\n1: Formulate vehicle control problem as a MILP\nwith the set of obstacle avoidance times\n{t o [k]} [N] k=1 [o] [ ]\n\n2: Set obstacle buffer zone for each obstacle j,\nR buff [(][j][)] [:=][ αR] obst [(][j][)] [where][ α >][ 1 ]\n\n3: Solve MILP with obstacles of radius R buff [(][j][)] [for]\neach obstacle j 4: Check resulting trajectory for collisions with obstacles of radius R obst [(][j][)] [for each obstacle][ j][ ]\n\n5: while there are collisions do\n\n\n6: For each collision i, compute time interval\n\n[t [(] 1 [i][)] [, t] [(] 2 [i][)] [] ]\n7: For each collision i, augment the MILP formulation with obstacle avoidance constraints at\ntime t [new] o ∈ [t [(] 1 [i][)] [, t] [(] 2 [i][)] [] ]\n8: Solve augmented MILP with obstacles of radius\nR buff [(][j][)] [for each obstacle][ j][ ]\n9: Check resulting trajectory for collisions with\nobstacles of radius R obst [(][j][)] [for each obstacle][ j][ ]\n\n10: end while\n\n\n3 2 Iterative MILP time step selection algorithm\n\n\nIt is advantageous to use as few avoidance times as possible Next, we propose an iterative algorithm to do so The method distributes avoidance times\nwhere they are needed most, as shown in Figure 1(c), and guarantees obstacle avoidance if an obstacle free trajectory exists The idea is to first solve the\nMILP with no obstacle avoidance times (or with a coarse set of avoidance times)\nand check the resulting trajectory for collisions Then, if there are collisions,\naugment the MILP formulation with an avoidance time (and the corresponding binary variables and constraints) for each collision The avoidance time for\neach collision is taken from the interval of time that the trajectory is within the\nobstacle Next, solve the augmented MILP and check the resulting trajectory\nfor collisions, repeating the procedure until a collision free trajectory is found The algorithm is outlined in Table 1 and proceeds as follows: First, formulate\nthe vehicle control problem as a MILP and choose an initial set of avoidance\ntimes {t o [k]} [N] k=1 [o] [ This set is usually taken to be the empty set or a coarsely]\ndistributed set of times",
    "This set is usually taken to be the empty set or a coarsely]\ndistributed set of times Next, introduce a buffer zone for each obstacle j with\nradius R buff [(][j][)] [=][ αR] obst [(][j][)] [, where][ α >][ 1 is the buffer factor Radius][ R] buff [(][j][)] [is larger]\n\nthan R obst [(][j][)] [(usually taken slightly larger) and is used as the radius of obstacle]\n\n\n8\n\n\n0 4\n\n\n0 2\n\n\n0\n\n\n−0 2\n\n\n0 4\n\n\n0 2\n\n\n0\n\n\n−0 2\n\n\n0 4\n\n\n0 2\n\n\n0\n\n\n−0 2\n\n\n\niteration 0\n\n\n−0 5 0 0 5\n\niteration 2\n\n\n−0 5 0 0 5\n\niteration 6\n\n\n−0 5 0 0 5\n\n\n\n0 4\n\n\n0 2\n\n\n0\n\n\n−0 2\n\n\n0 4\n\n\n0 2\n\n\n0\n\n\n−0 2\n\n\n0 4\n\n\n0 2\n\n\n0\n\n\n−0 2\n\n\n\niteration 1\n\n\n−0 5 0 0 5\n\niteration 5\n\n\n−0 5 0 0 5\n\niteration 8\n\n\n−0 5 0 0 5\n\n\n\nFigure 2: Snapshots of the iterative MILP obstacle avoidance algorithm The\ncircular regions denote obstacles, and the polygons denote the buffer regions\nused in the MILP formulation Each cross ‘×’ denotes a time at which obstacle\n\navoidance is enforced The values of the parameters are M o = 6, M u = 4, N u =\n4, (x s, y s, ˙x s, ˙y s ) = (−0 25, −0 2, −0 5, 0 3), and (x f, y f, ˙x f, ˙y f ) = (0 4, 0 3, 0, 0) j in the MILP formulation This is done to guarantee obstacle avoidance and\ntermination of the algorithm, which we show later in this section Next, solve\nthe MILP using the buffer regions as the obstacles Then, check the resulting\ntrajectory for collisions using each obstacle’s true radius, R obst [(][j][)] [for each obstacle]\nj To check for collisions, sample the trajectory and check whether or not each\nsample point is inside any of the obstacles If there are no collisions, terminate the algorithm Otherwise, for each collision i, compute the time interval [t [(] 1 [i][)] [, t] [(] 2 [i][)] [] in which the trajectory is within]\nthe obstacle This interval can be computed efficiently using a bisection routine\nand the collision check routine Then, for each collision i, augment the MILP\nproblem formulation with avoidance constraints at time t [new] o taken to be in the\ninterval [t [(] 1 [i][)] [, t] [(] 2 [i][)] [] In this paper, we take][ t] o [new] = (t [(] 1 [i][)] + t [(] 2 [i][)] [)][/][2 Next, solve the]\naugmented MILP and check the resulting trajectory for collisions If there are\nno collisions, terminate the algorithm Otherwise, repeat the procedure until\nthere are no collisions Snapshots of intermediate steps in the iterative algorithm are shown in Figure 2 The procedure adds obstacle avoidance points where they are needed\nmost, thus avoiding unnecessary and computationally costly constraints and\nbinary variables 9\n\n\nto[k+1]\n\n\nto[k]\n\n\n\nto[k+1]\n\n\nto[k]\n\n\n\nt o [k + 1] − t o [k] ≥ 2∆t min t o [k + 1] − t o [k] < 2∆t min\n\n\nFigure 3: These diagrams help show that the iterative MILP time selection\nalgorithm terminates If the difference between consecutive obstacle avoidance\ntimes, denoted t o [k + 1] − t o [k], is greater than 2∆t min, the trajectory can intersect the obstacle as shown in the figure on the left In this case, the algorithm\nwill add a new avoidance constraint at time t [new] o If the difference is less than\n2∆t min, the trajectory can not intersect the obstacle, and a new avoidance constraint can not be added in between Now we show that the iterative algorithm in Table 1 terminates The\nminimum distance between the boundary of a buffer zone and the boundary\nof the obstacle it surrounds is d = R buff − R obst = (α − 1)R obst For a\nproblem involving multiple obstacles, the minimum of these distances is given\nby d min = (α − 1)R obst [min] [, where][ R] obst [min] [is the radius of the smallest obstacle]\nin the environment The minimum time it takes the vehicle to travel between the boundary of a buffer zone and its corresponding obstacle is given\nby ∆t min = d min /v max = (α − 1)R obst [min] [/v] [max] [, where][ v] [max] [ is the maximum veloc-]\nity of the vehicle Consider two consecutive obstacle avoidance times denoted\nt o [k] and t o [k + 1] The vehicle must be located outside all buffer zones at these\ntwo times because we have enforced this as a hard constraint in the MILP If\nthe difference t o [k + 1] − t o [k] is less than 2∆t min, the vehicle’s trajectory can\nnot intersect the obstacle because there is not enough time to enter the buffer\nzone, collide with the obstacle, then exit the buffer zone (see Figure 3) In\norder for the trajectory to intersect the obstacle in the interval between these\ntwo times, the difference t o [k + 1] − t o [k] must be greater than 2∆t min In\nsummary, the algorithm will not add an obstacle avoidance time in the interval if t o [k + 1] − t o [k] < 2∆t min, but it can add an obstacle avoidance time if\nt o [k + 1] − t o [k] ≥ 2∆t min Therefore, in the worst case, once the algorithm\nreaches a point where the time interval between each obstacle avoidance time is\nless than 2∆t min, the algorithm must terminate Next we bound the number of steps it takes for the algorithm to terminate The smallest possible time interval between consecutive obstacle avoidance times\nis ∆t min This can be seen by looking at Figure 4, where t o [k + 1] and t o [k]\nare two consecutive avoidance times and t 1 is the time at which the trajectory\nenters the obstacle and t 2 is the time it exits the obstacle Suppose the vehicle\nis moving at its maximum velocity from time t o [k] to t 1 The algorithm will\ndetect this intersection, compute times t 1 and t 2, and pick a new obstacle avoidance time t [new] o in the interval [t 1, t 2 ] Suppose the algorithm picks t [new] o = t 1,\n\n\n10\n\n\nt o [k]\n\n\n\n\n\n\n\nmin\n\n\n\nFigure 4: This diagram helps show the minimum time step that can be added by\nthe iterative MILP time step selection algorithm The trajectory intersects the\nobstacle in the interval [t 1, t 2 ] Assume the vehicle is moving at v max between\ntimes t o [k] and t 1 If the algorithm selects t 1 as the new obstacle avoidance\ntime, the difference t 1 − t o [k] is equal to ∆t min This is the minimum possible\ntime interval between avoidance times because the vehicle can not move any\nfaster then t [new] o − t o [k] = ∆t min The time interval can not be any less because the\nvehicle can not pass through the buffer zone in time less than ∆t min In the\ntrajectory generation problem, if t s is the vehicle’s starting time and t f is its\nfinishing time, the maximum number of time intervals added by the algorithm\nis ⌊(t f − t s )/∆t min ⌋ Therefore, the algorithm will terminate in a maximum of\n⌊(t f − t s )/∆t min ⌋ steps This is a worst case result In practice the algorithm\nterminates in fewer steps 3 3 Iterative MILP obstacle growing algorithm\n\n\nBeing consistent with our goal to reduce the number of obstacle avoidance times\nin our MILP problem formulations, we propose another iterative MILP algorithm for obstacle avoidance This algorithm iteratively grows the buffer zones\nsurrounding the obstacles until a collision free trajectory is found The idea is\nto first solve the MILP with a coarse set of avoidance times and an initial set\nof buffer zones surrounding each obstacle Then, check the resulting trajectory\nfor collisions If there are collisions, increase the size of each buffer zone that\nsurrounds an obstacle with which the trajectory collides Next, solve the MILP\nwith these new buffer zones and check the resulting trajectory for collisions This process is repeated until there are no collisions The details of the algorithm are listed in Table 2 Snapshots of intermediate\nsteps of the algorithm are shown in Figure 5 The crosses denote the coarse\nset of times at which obstacle avoidance is enforced in the MILP As the figure\nshows, the size of the buffer regions surrounding the obstacles with which the\ntrajectory intersects is increased until the resulting trajectory, generated by the\nMILP, avoids all obstacles The situation in which this algorithm is most useful is when uniform gridding\nis used and the resulting trajectory clips an obstacle, barely intersecting it In\n\n\n11\n\n\nTable 2: Iterative MILP obstacle growing algorithm\n\n\n1: Formulate vehicle control problem as a MILP\nwith the set of obstacle avoidance times\n{t o [k]} [N] k=1 [o] [ ]\n\n2: Set obstacle buffer zone for each obstacle j,\nR buff [(][j][)] [:=][ αR] obst [(][j][)] [where][ α >][ 1 ]\n\n3: Solve MILP with obstacles of radius R buff [(][j][)] [for]\neach obstacle j 4: Check resulting trajectory for collisions with obstacles of radius R obst [(][j][)] [for each obstacle][ j][ ]\n\n5: while there are collisions do\n\n\n6: For each obstacle j that collides with the trajectory, increase buffer region by setting R buff [(][j][)] [:=]\n\nαR [(][j][)]\nbuff [ ]\n\n7: Solve MILP with obstacles of radius R buff [(][j][)] [for]\neach obstacle j 8: Check resulting trajectory for collisions with\nobstacles of radius R obst [(][j][)] [for each obstacle][ j][ ]\n\n9: end while\n\n\nthis case, the algorithm pushes the trajectory away from the clipped obstacle in\na few iterations, resulting in a collision free trajectory However, if the initial\ndistribution of avoidance times is too coarse, the algorithm could have problems In this case, the buffer regions could grow to be large and engulf the initial or\nfinal position, which results in an infeasible MILP",
    "In this case, the buffer regions could grow to be large and engulf the initial or\nfinal position, which results in an infeasible MILP 3 4 Average case complexity\n\n\nIn this section, we explore the average case computational complexity of the\niterative MILP obstacle avoidance algorithm by solving randomly generated\nproblem instances Each instance is generated by randomly picking parameters\nfrom a uniform distribution over the intervals defined below Each MILP is\nsolved using AMPL [13] and CPLEX [15] on a PC with Intel PIII 550MHz\nprocessor, 1024KB cache, 3 8GB RAM, and Red Hat Linux For all instances\nsolved, processor speed was the limiting factor, not memory For comparison, we solve the same instances using uniform gridding with\nsample time ∆t c = 2R obst [min] √α [2] − 1/v max This sample time is the maximum\n\nsample time that guarantees obstacle avoidance, assuming the vehicle travels\nin a straight line between sample times This is a good approximation since\n∆t c is small for the instances we solve This is a good approximation since\n∆t c is small for the instances we solve See Appendix A for details Each\nobstacle avoidance time is given by t o [k] = k∆t c, where k = 1, , N o and\n\n\n12\n\n\niteration 0 iteration 3\n\n\niteration 4 iteration 6\n\n\nFigure 5: Snapshots of the iterative MILP obstacle growing algorithm The\ncircular regions denote obstacles, and the polygons denote the buffer regions\nused in the MILP formulation Each cross denotes a time at which obstacle\n\navoidance is enforced N o = ⌈t f /∆t c ⌉ The instances are generated as follows: The start state is taken to be\nx s = (x s, y s, r v cos θ v, r v sin θ v ), where (x s, y s ) is constant, and r v and θ v are\nrandom variables chosen uniformly from the intervals [r v [min], r v [max] ] and (0, 2π],\nrespectively The final state is fixed with zero velocity, x f = (x f, y f, 0, 0) We\ngenerate N obst obstacles each with position (x obst, y obst ) = (r cos θ, r sin θ) and\nradius R obst The parameters R obst, r, and θ are random variables chosen uniformly from the respective intervals [R min, R max ], [r min, r max ], and (0, 2π] such\nthat no obstacle overlaps the circle of radius R s with position (x s, y s ) or the\ncircle of radius R f with position (x f, y f ) For the instances generated in this paper, we set the intervals to be r v ∈\n\n[0 5, 1 0], R obst ∈ [0 2, 0 3], and r ∈ [0 0, 1 0] The constant parameters are taken\nto be (x s, y s ) = (−0 8, −0 8), (x f, y f ) = (1 0, 1 0), R s = 0 5, and R f = 0 1 The solution to an instance of the obstacle avoidance problem with three\nobstacles is shown in Figure 6 for the the uniform gridding method and for the\niterative MILP methods Each cross denotes the time along the trajectory at\nwhich obstacle avoidance is enforced The uniform gridding method with sample time ∆t c requires N o = 25 obstacle avoidance times, shown in Figure 6(b),\nwhile the iterative MILP time step selection algorithm requires only N o = 4\navoidance times, shown in Figure 6(c) Notice the efficiency in which the iterative algorithm distributes the avoidance times For comparison, we also solve\n\n\n13\n\n\n(a) (b)\n\n\n(c) (d)\n\n\nFigure 6: Solutions to an instance of the obstacle avoidance problem using: (a)\nuniform gridding with sample time 2∆t min (N o = 115), (b) uniform gridding\nwith sample time ∆t c (N o = 25), (c) iterative time step selection (N o = 4), and\n(d) iterative obstacle growing (N o = 5) The straight line segment denotes the\ninitial velocity ( ˙x s, ˙y s ) = (0 497, 0 172), the circular regions denote obstacles,\nthe dashed regions denote the polygonal buffer zones, and each cross denotes a\ntime along the trajectory at which obstacle avoidance is enforced this instance using uniform gridding with sample time 2∆t min (Figure 6(a))\nand using the iterative obstacle growing algorithm (Figure 6(d)) For uniform\ngridding, choosing sample time 2∆t min guarantees obstacle avoidance as discussed in Section 3 2",
    "2 However, as shown in the figure, this dense set of obstacle\navoidance times is very conservative In Figure 7, we plot the fraction of instances solved versus computation time\nfor the two methods As these figures show, the iterative MILP method is less\ncomputationally intensive than the uniform gridding method for the instances\nsolved For example, 70% of the instances are solved in 0 4 seconds or less using\nthe iterative MILP algorithm for the 3 obstacle case In contrast, no instances\nare solved in 0 4 seconds or less using uniform gridding for the 3 obstacle case In Figure 8, we plot the computation time necessary to solve 70% of the\nrandomly generated instances versus the number of obstacles on the field Data\nis plotted for the uniform gridding method and for the iterative MILP method The computational requirements for both methods grow exponentially with the\nnumber of obstacles However, as the figure shows, the iterative MILP method\nis less computationally intensive and the computation time grows at a slower\n\nrate 14\n\n\n1 uniform gridding\n\n\n\n\n\n0 8\n\n\n0 6\n\n\n0 4\n\n\n0 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n0\n0 1 2 3 4 5 6 7\n\ncomputation time (sec)\n\n\n1 iterative time step selection\n\n\n\n\n\n0 8\n\n\n0 6\n\n\n\n\n\n\n\n\n\n0 4\n\n\n0 2\n\n\n0\n0 1 2 3 4 5 6 7\n\ncomputation time (sec)\n\n\nFigure 7: Fraction of instances solved versus computation time for uniform\ngridding (top) and the iterative MILP obstacle avoidance (bottom) We consider\nN obst = 2, 3, 4 For each curve, 500 random instances were solved The values\nof the parameters are N u = 10, M u = 10, and M o = 10 15\n\n\n10 2\n\n\n\n\n\n10 1\n\n\n10 0\n\n\n10 −1\n1 2 3 4 5 6\n\nobstacles\n\n\nFigure 8: Computation time necessary to solve 70% of the randomly generated\ninstances versus the number of obstacles Each square denotes a data point\nfor the uniform gridding method Each asterisk denotes a data point for the\niterative MILP method The solid lines denote curves fitted to these data",
    "The solid lines denote curves fitted to these data ### 4 Minimum time problems\n\n\nIn this section, we present an iterative MILP algorithm for solving minimum\ntime problems using a vehicle trajectory generation problem as motivation In [21, 22], MILP methods for this problem are presented Time is discretized\nuniformly and the sampling interval that contains the optimal time is found\nusing MILP To get better bounds on the optimal time, the sample time of\nthe discretization must be reduced, which results in a larger number of binary\nvariables In Appendix B, this method is outlined in the context of the vehicle\nconsidered in this paper Here we propose an iterative algorithm that converges to the optimal time\nusing binary search At each iteration the feasibility of a MILP is determined\nusing a solver such as CPLEX [15] In each MILP, the number of binary variables\nand the number of constraints are much fewer than those for other techniques\nbecause only one discrete time step is needed To motivate the iterative algorithm we consider a minimum time vehicle\ncontrol problem Given a vehicle governed by equations (5) and (7), find the\nsequence of control inputs {u[k]} [N] k=0 [u] [−][1] that transfers the vehicle from initial\nstate x(0) = x s to final state x(t f ) = x f in minimum time Suppose we know that the optimal time, denoted t [∗], is within the time\ninterval (t L, t R ] Let time t M = (t L + t R )/2 Consider the MILP given by\nequation (5), equation (7), constraint x(0) = x s, and constraint x(t f ) = x f\nwith final time taken to be t f = t M We use equation (6) to express x(t f ) in\nterms of the control inputs To determine if there exists a sequence of control\ninputs that transfers the vehicle from start state to finish state, we solve the\n\n\n16\n\n\nTable 3: Iterative minimum time MILP algorithm\n\n\n1: Formulate problem as a MILP without objective function 2: Set t L := t lb and t R := t ub 3: Set t M := (t R + t L )/2 4: while (t R − t L ) > ǫ do\n\n5: Determine feasibility of MILP with final\ntime t f = t M 6: if feasible then set t R := t M 7: else set t L := t M 8: Set t M := (t R + t L )/2 9: end while\n\n\nMILP without an objective function (this is a feasibility problem) If the MILP is feasible, t [∗] must be within the interval (t L, t M ] Otherwise,\nthe MILP is infeasible and t [∗] must be within the interval (t M, t R ] By determining the feasibility of the MILP, we have cut the bound on the optimal time\nt [∗] in half This suggests an iterative binary search procedure that converges to\nt [∗] The iterative algorithm is outlined in Table 3 and proceeds as follows: First,\npick a time interval (t lb, t ub ] that bounds the optimal time t [∗] The lower bound\nis taken to be t lb = d min /v max, where d min is the straight line distance from the\ninitial position to the final position and v max is the maximum velocity of the\nvehicle The upper bound is taken to be a feasible time in which the vehicle\ncan reach the destination A simple way to compute a feasible time is to try\ntime αt lb, where α > 1, increasing α until a feasible time is found Set t L := t lb,\nt R := t ub, and t M := (t R + t L )/2 Next, set the final time in the MILP problem formulation to be t f = t M,\nand determine if the resulting MILP is feasible using the MILP solver If the\nMILP is feasible, the optimal time t [∗] must be within the interval (t L, t M ] In\nthis case, set t R := t M Otherwise, the MILP is infeasible and the vehicle can\nnot reach the destination in time t M The optimal time t [∗] must be within\nthe interval (t M, t R ] In this case, set t L := t M Then, update t M by setting\nt M := (t R + t L )/2 If the difference t R − t L is less than some desired tolerance\nfor our calculation of t [∗], denoted ǫ, the algorithm terminates Otherwise, repeat\nthe process by setting the final time to t f = t M and continue with the steps\noutlined previously until the computed value of t [∗] is within the desired tolerance\n\nǫ After the kth iteration, the time interval containing optimal time t [∗] has\nlength (t ub − t lb )/2 [k] The solid lines of Figure 9 show the solution to an instance of the minimum\ntime problem The iterative procedure was stopped after thirteen iterations,\n\n\n17\n\n\n(a)\n\n0 3\n\n\n0 2\n\n\n0 1\n\n\n0\n\n\n−0 1\n\n\n−0 2\n−0 2 0 0 2 0 4\n\n\nx\n\n\n(c)\n\n0 4\n\n\n0 3\n\n\n0 2\n\n\n0 1\n\n\n0\n\n\n−0 1\n\n\n−0 2\n\n\n−0 3\n\n\n0 0 5 1 1 5 2\n\n\ntime\n\n\n\n(b)\n\n1\n\n\n0 5\n\n\n0\n\n\n−0 5\n\n\n−1\n0 0 5 1 1 5 2\n\n\ntime\n\n\n(d)\n\n\n0 6\n\n\n0 4\n\n\n0 2\n\n\n0\n\n\n−0 2\n\n\n−0 4\n\n\n0 0 5 1 1 5 2\n\n\ntime\n\n\n\nFigure 9: Time optimal solution (solid lines) to an instance of the minimum\ntime vehicle control problem of Section 4 given by the iterative MILP algorithm For comparison we plot the near optimal solution (dotted lines) for the\ncontinuous time version of the problem obtained using techniques from [18] The\nparameters are: M u = 20, N u = 10, (x s, y s, ˙x s, ˙y s ) = (−0 25, −0 2, −0 5, 0 3),\n(x f, y f, ˙x f, ˙y f ) = (0 4, 0 3, 0, 0)",
    "3, 0, 0) which took approximately one second on our Pentium III 550 MHz computer To achieve the same accuracy using the uniform time discretization method,\nsolving one large MILP with a small sampling time, it took five minutes on the\nsame computer Our iterative procedure converges to the time optimal solution of the problem stated in the beginning of this section This solution is an approximate\nsolution to the continuous time version of the minimum time vehicle control\n\nproblem In the continuous time version of the problem, the vehicle is governed\nby equations (4) and (3) We wish to transfer the vehicle from starting state x s\nto finishing state x f in minimum time In Figure 9, we compare our near optimal solution to the continuous time problem (solid lines) to another technique\n(dotted lines) for generating near optimal solutions from [18], which was used\nsuccessfully in the RoboCup competition In addition to being used on its own, our iterative approach can be combined\nwith the uniform discretization approach In this case, the uniform approach is\nrun first with a coarse discretization (large sampling time T ) The output is a\ntime interval of size T, which contains the optimal time t [∗] We use this time\ninterval as the input to our iterative algorithm The kth step of the iterative\nalgorithm outputs a time interval of length T/2 [k] containing the optimal time\nt [∗], and thus quickly converges to the optimal time 18\n\n\n### 5 Discussion\n\nWe have presented iterative MILP algorithms for obstacle avoidance and for\nminimum time control problems The iterative MILP time selection algorithm\npicks obstacle avoidance times and intelligently distributes them where they are\nneeded most The iterative MILP obstacle growing algorithm allows a course\nset of obstacle avoidance times to be used instead of a dense distribution, which\nis required to guarantee obstacle avoidance for standard MILP methods Both\nof these algorithms reduce the number of binary variables needed to formulate and solve obstacle avoidance trajectory generation problems using MILP To demonstrate the computational benefits of the iterative MILP time step\nselection algorithm, we performed an average case computational complexity\nanalysis For comparison, we also performed the analysis on the standard uniform gridding method The iterative algorithm significantly outperformed the\nuniform gridding method In addition, we also present an iterative algorithm\nfor solving minimum time problems using MILP We found that the algorithm\nsignificantly outperforms standard techniques for minimum time problems using\nMILP Due to the reduced computational requirements of these methods, they can\nbe applied more widely in practice Computational efficiency is especially important for real time control in dynamically changing environments where new\ncontrol plans need to be generated often and in real time using a strategy such\nas model predictive control [16] In our research [8, 9], we use these methods\nto solve cooperative control problems such as those described in [4, 6, 7] However, there is much room for improvement, including decreasing computation\ntime further and developing methods that scale better with increased numbers\nof obstacles and vehicles In [8] we discuss ideas to further decrease the computational requirements of MILP methods We feel that intelligent time step\nselection methods, such as those presented in this paper, can be very useful\nin reducing computational requirements and should be pursued further One\naspect that needs inspection is the intelligent selection of the discretization for\nthe control input to the vehicle ### A Appendix: Sample time\n\n\nHere we derive the minimum sample time, denoted ∆t c, that guarantees obstacle\navoidance between sample times, assuming the vehicle moves in a straight line\npath between sample times This is a good approximation, because ∆t c is small\nfor the problems we solve Let d be the straight line distance the vehicle can travel between any two\nconsecutive avoidance times The cord of the smallest buffer region that is\ntangent to the obstacle it surrounds is denoted the critical cord The critical\ncord length is given by d c = 2((R buff [min] [)] [2] [ −] [(][R] obst [min] [)] [2] [)] [1][/][2] [ = 2][R] obst [min] √α [2] − 1 because\n\nR buff [min] [=][ αR] obst [min] [ ]\nIf d < d c, the vehicle is guaranteed to avoid the obstacle between avoidance\n\n\n19\n\n\ntimes If d ≥ d c, the vehicle can collide with the obstacle between avoidance\ntimes The critical time interval ∆t c is given by\n\n\n∆t c = d c = [2][R] obst [min] √α [2] − 1, (14)\nv max v max\n\n\nwhere v max is the maximum velocity of the vehicle ### B Appendix: Minimum time MILP formulation\n\n\nHere we consider a minimum time trajectory generation problem We are given\na vehicle governed by the discrete time system (5) and subject to the constraints (7) The objective is to find the sequence of control inputs {u[k]} k [N] =0 [u] [−][1]\nthat transfers the system from the initial state x(0) = x s to the final state\nx(t f ) = x f in minimum time Applying the techniques of [21, 22], we introduce a uniform time discretization with constant sampling time T The solution of the resulting MILP gives\na feasible time that is within T of the optimal time Discretize time into N T times given by t T [k] = kT, where k is an element of\nthe set {1, , N T } The discretization must be chosen so that t T [N T ] = N T T\nis larger than the optimal time Next, introduce auxiliary binary variable δ[k] ∈{0, 1} and the inequality\nconstraints,\n\n\nx(t T [k]) − x f ≤ H(1 − δ[k])\n\nx(t T [k]) − x f ≥−H(1 − δ[k])\ny(t T [k]) − y f ≤ H(1 − δ[k])\n\ny(t T [k]) − y f ≥−H(1 − δ[k])\n\n˙ ˙\nx(t T [k]) − x f ≤ H(1 − δ[k])\n\n\n˙ ˙\nx(t T [k]) − x f ≥−H(1 − δ[k])\n\n˙ ˙\ny(t T [k]) − y f ≤ H(1 − δ[k])\n\n\n˙ ˙\ny(t T [k]) − y f ≥−H(1 − δ[k]), (15)\n\n\nfor each k in the set {1, , N T } Here, the state x(t T [k]) is written in terms of\nthe control inputs using equation (6), and H is a large positive constant taken\nto be greater than the largest dimension of the operating environment If δ[k] = 0, every constraint in equation (15) is trivially satisfied because,\nfor example, x(t T [k]) − x f is always less than H Otherwise, δ[k] = 1 and the\nconstraints in equation (15) enforce the condition x(t T [k] = x f ) To require\nthat the final condition be satisfied at only one discrete time t T [k] the following\nconstraint is introduced,\nN T\n� δ[i] = 1 (16)\n\n\ni=1\n\n\n20\n\n\nFinally, we introduce the cost function to be minimized,\n\n\n\nJ =\n\n\n\nN T\n� iδ[i] (17)\n\n\ni=1\n\n\n\nBy minimizing this cost the final state x f is reached at the earliest discrete\ntime, t T [k], possible The output after solving the resulting MILP is a single\nk sol such that δ[k sol ] = 1 The optimal time is therefore within the interval\n(t T [k sol − 1], t T [k sol ]] ### References\n\n\n[1] J S Bellingham, M Tillerson, M Alighanbari, and J P How, “Cooperative\nPath Planning for Multiple UAVs in Dynamic and Uncertain Environments,”\nProc IEEE Conf Decision and Control, Las Vegas, Neveda, Dec 2002, pp 2816–2822 [2] A Bemporad and M Morari, “Control of Systems Integrating Logic, Dynamics, and Constraints,” Automatica, vol 35, pp 407–428, 1999 [3] D Bertsimas and J N Tsitsiklis, Introduction to Linear Optimization,\nAthena Scientific, Belmont, Massachusetts, 1997",
    "Tsitsiklis, Introduction to Linear Optimization,\nAthena Scientific, Belmont, Massachusetts, 1997 [4] M Campbell, R D’Andrea, D Schneider, A Chaudhry, S Waydo, J Sullivan, J Veverka, and A Klochko, “RoboFlag Games Using Systems Based,\nHierarchical Control,” Proceedings of the American Control Conference,\nJune 4–6, 2003, pp Klochko, “RoboFlag Games Using Systems Based,\nHierarchical Control,” Proceedings of the American Control Conference,\nJune 4–6, 2003, pp 661–666 [5] R D’Andrea, T Kalm´ar-Nagy, P Ganguly, and M Babish, “The Cornell\nRoboCup Team,” In G Kraetzschmar, P Stone, T Balch Eds , Robot Soccer\nWorldCup IV, Lecture Notes in Artificial Intelligence, Springer, 2001 [6] R D’Andrea and R M Murray, “The RoboFlag Competition,” Proceedings\nof the American Control Conference, June 4–6, 2003, pp 650–655 [7] R D’Andrea and M Babish, “The RoboFlag Testbed,” Proceedings of the\nAmerican Control Conference, June 4–6, 2003, pp 656–660 [8] M G Earl and R D’Andrea, “Multi-vehicle Cooperative Control Using\n[Mixed Integer Linear Programming,” A preprint is available at cs/0501092](http://arxiv org/abs/cs/0501092)\n\n\n[9] M G Earl and R D’Andrea, “A Decomposition Approach to Multi-vehicle\n[Cooperative Control,” A preprint is available at cs/0504081](http://arxiv org/abs/cs/0504081)\n\n\n[10] M G Earl and R D’Andrea, “A Study in Cooperative Control: The\nRoboFlag Drill,” Proceedings of the American Control Conference, Anchorage, Alaska May 8–10, 2002, pp 1811–1812 21\n\n\n[11] M G Earl and R D’Andrea, “Modeling and Control of a Multi-agent System Using Mixed Integer Linear Programming,” Proc IEEE Conf Decision\nand Control, Las Vegas, Nevada, Dec 2002, pp 107–111 [12] All files for generating the plots found in this paper are available online at\nhttp://control",
    "[12] All files for generating the plots found in this paper are available online at\nhttp://control mae cornell edu/earl/milp2\n\n\n[13] R Fourer, D M Gay, B W Kernighan, “AMPL–A Modeling Language For\nMathematical Programming,” Boyd & Fraser, 1993 http://www ampl com\n\n\n[14] M R Garey and D S Johnson Computers And Intractability: A guide to\nthe Theory of NP-Completeness W H Freeman and Co , 1979 [15] ILOG AMPL CPLEX System Version 7 0 User’s Guide, 2000 http://www ilog com/products/cplex\n\n\n[16] D Q Mayne, J B Rawlings, C V Rao, and P O M Scokaert, “Constrained Model Predictive Control: Stability and Optimality,” Automatica,\nvol Scokaert, “Constrained Model Predictive Control: Stability and Optimality,” Automatica,\nvol 36, pp 789–814, 2000 [17] M Morari, M Baotic, and F Borrelli, “Hybrid Systems Modeling and\nControl,” European Journal of Control, Vol Borrelli, “Hybrid Systems Modeling and\nControl,” European Journal of Control, Vol 9, No 2-3, pp 177-189, 2003 [18] T Kalm´ar-Nagy, R D’Andrea, and P Ganguly “Near-Optimal Dynamic\nTrajectory Generation and Control of an Omnidirectional Vehicle,” Robotics\nand Autonomous Systems, vol “Near-Optimal Dynamic\nTrajectory Generation and Control of an Omnidirectional Vehicle,” Robotics\nand Autonomous Systems, vol 46, pp 47–64, 2004 [19] J Ousingsawat and M E Campbell, “Establishing Optimal Trajectories\nfor Multi-vehicle Reconnaissance,” AIAA Guidance, Navigation and Control\nConference, 2004 [20] A Richards, T Schouwenaars, J P How, and E How, and E Feron, “Spacecraft Trajectory Planning with Avoidance Constraints Using Mixed-Integer Linear\nProgramming,” Journal of Guidance, Control, and Dynamics, Vol 25, pp 755–764, July–August 2002 [21] A Richards and J P How, “Aircraft Trajectory Planning With Collision\nAvoidance Using Mixed Integer Linear Programming,” Proc American Control Conf , Anchorage, Alaska May 8–10, 2002 [22] H P Rothwangl, “Numerical Synthesis of the Time Optimal Nonlinear\nState Controller via Mixed Integer Programming,” Proc American Control\nConf , Arlington, VA, June 2001, pp 3201–3205 [23] P Stone, M Asada, T Balch, R D’Andrea, M Fujita, B Hengst, G Kraetzschmar, P Lima, N Lau, H Lund, D Polani, P Scerri, S Tadokoro,\nT Weigel, and G Wyeth, “RoboCup-2000: The Fourth Robotic Soccer\nWorld Championships,” AI MAGAZINE, vol Wyeth, “RoboCup-2000: The Fourth Robotic Soccer\nWorld Championships,” AI MAGAZINE, vol 22(1), pp 11–38, Spring 2001 22"
  ]
}