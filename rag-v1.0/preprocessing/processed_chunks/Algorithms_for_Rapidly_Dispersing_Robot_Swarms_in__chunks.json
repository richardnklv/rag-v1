{
  "filename": "Algorithms_for_Rapidly_Dispersing_Robot_Swarms_in_.pdf",
  "text_length": 46372,
  "chunk_count": 12,
  "chunks": [
    "## Algorithms for Rapidly Dispersing Robot Swarms in Unknown Environments\n\nTien-Ruey Hsiang [1], Esther M Arkin [1], Michael A Bender [1],\nS´andor P Fekete [2], and Joseph S B Mitchell [1]\n\n\n1 Stony Brook University, Stony Brook, NY 11794, USA\n2 TU Braunschweig, 38106 Braunschweig, Germany\n\n\nAbstract Mitchell [1]\n\n\n1 Stony Brook University, Stony Brook, NY 11794, USA\n2 TU Braunschweig, 38106 Braunschweig, Germany\n\n\nAbstract We develop and analyze algorithms for dispersing a swarm of primitive\nrobots in an unknown environment, R The primary objective is to minimize the\nmakespan, that is, the time to fill the entire region An environment is composed of\npixels that form a connected subset of the integer grid There is at most one robot\nper pixel and robots move horizontally or vertically at unit speed Robots enter R\nby means of k ≥ 1 door pixels Robots are primitive finite automata, only having\nlocal communication, local sensors, and a constant-sized memory We first give algorithms for the single-door case (i e , k = 1), analyzing the\nalgorithms both theoretically and experimentally We prove that our algorithms\nhave optimal makespan 2A − 1, where A is the area of R We next give an algorithm for the multi-door case (k ≥ 1), based on a wallfollowing version of the leader-follower strategy We prove that our strategy is\nO(log(k + 1))-competitive, and that this bound is tight for our strategy and other\nrelated strategies 1 Introduction\n\n\nThe objective of swarm robotics is to program a huge number of simple, tiny\nrobots to perform complex tasks collectively A typical application scenario\nfor a robot swarm may involve two phases: first, the robot swarm fills an\nenvironment as quickly as possible while keeping the swarm “connected”\n(a term made more precise later) Once the robots are distributed in the\nenvironment, the robots perform world-embedded computational tasks, such\nas computing distances and short paths between points in the environment,\nfinding chokepoints, mapping the environment, and searching for intruders This paper develops efficient algorithms for filling an environment with\na swarm of robots, thus focusing on the first phase described above Because target applications require thousands to millions of robots and current\ndemonstration scenarios have at most hundreds of robots, it is crucial to\ndevelop algorithms that have explicitly stated performance guarantees, thus\nensuring scalability There has already been work on dispersion algorithms, but most dispersion algorithms rely on greedy strategies such as go-for-free space, where\nrobots move to fill unoccupied space, or artificial physics strategies, where\nneighboring robots exert “forces” on each other: repulsion forces if the robots\n\n\n2 Hsiang et al are closer than the target separation, and attraction forces if the neighboring\nrobots are too far away Although such robot behaviors often lead to reasonable dispersion, there are cases in which the swarm enters infinite loops, never\nfilling the domain Even in artificial physics strategies, which seem to disperse\nrobots most efficiently, there are no guarantees on filling time Furthermore,\nthe swarm behavior under artificial-physics rules results in dispersions that\nare more reminiscent of molecular dynamics simulations (with large amounts\nof “bouncing” and “jitter”) than of the ideal coordinated behavior of cooperating teams of robots The dispersion algorithms in this paper represent a departure from previously studied dispersion strategies First of all, we test our algorithms in\narbitrary polygonal environments, rather than restricting ourselves to rectangles or the infinite plane It is important to study the dispersion algorithms in complicated polygonal domains because the target domains may\nbe bottleneck-filled indoor environments or systems of pipes or ductwork Our algorithms are based on follow-the-leader local rules, where the robots\nform chains of leaders and followers emanating from a central source of robots (the “doors”) The emergent behavior of our main algorithm is a left-handon-the-wall strategy, where the entire robot swarm hugs the left wall of the\ndomain as the filling proceeds We provide matching lower and upper bounds\non the amount of time to fill as a function of the total size of the source The difficulty in dispersing efficiently is in sustaining a large flow of robots\ncoming in through the doors; the “chains” of robots coming in through the\ndoors have a tendency to “cut each other off”; see Figure 1(left) Thus, we\ndevise a set of local rules for splitting and splicing the robot chains Our\nexperience with our robot simulator shows that unless the local rules are\nprecisely implemented, the flow of robots out of the source diminishes and\nperhaps even grinds to a halt prematurely Fig 1 Left: One turn can cut off most of the flow lines leading out of the door pixels\n(shaded grey): The left three columns of robots are trapped Right: A polygonal\ndomain encloses a discrete set of possible robot locations (pixels); special door pixels\nare shown in grey Rapidly Dispersing Robot Swarms 3\n\n\n1 1 Our Results\n\n\nWe develop and analyze algorithms for dispersing robot swarms in an unknown environment R The primary objective is to minimize the makespan,\nthat is, the time to fill the entire region An environment is composed of\nsquares or pixels that form a connected subset of the integer grid; such an\nenvironment is also called a maze There is at most one robot per pixel and\nrobots move horizontally or vertically at unit speed There is a source of\nrobots entering the environment through k ≥ 1 doors Robots are primitive finite automata, only having local communication, local sensors, and a\nconstant-sized memory The challenge is in proving that purely local strategies distributed over a swarm of agents can result in a predictable and provable behavior for the collective This paper presents the following results:\n\n\n - We give filling algorithms for the single-door case (i e",
    "e , k = 1), analyzing\nthe algorithms both theoretically and experimentally in terms of natural\nperformance metrics, such as makespan and total traveled distance by\nall robots Our algorithms are based on leader-follower strategies that\nare adapted from depth-first and breadth-first search to apply to robot\nswarms We prove that our algorithms have optimal makespan 2A − 1,\nwhere A is the area (number of pixels) of R - We give a filling algorithm for the multi-door case (k ≥ 1), also based\non a leader-follower strategy The emergent behavior of the swarm is a\nfilling strategy, called laminar flow, that generalizes the “left-hand-onwall” strategy to multiple streams of robots coming in through multiple\ndoors An important contribution of the algorithm is the formulation of\nsplitting and splicing strategies that maintain a large flow of robots out\nof the doors We prove that the laminar flow algorithm is O(log(k + 1))competitive, that is, the ratio of the makespan of our algorithm to the\noptimal makespan is O(log(k + 1)) - We give a matching lower bound of Ω(log(k + 1)) on the competitiveness\nof the natural class of “simple-minded” strategies that use only strictly\nlocal information - We report on experiments with a Java simulator that we built for swarms\nin grid environments All of the algorithms in this paper are implemented\nin this simulator While our results here are given purely in terms of robots moving synchronously on discrete grids, the results apply also to dispersing swarms of\nrobots within an arbitrary connected planar domain, in the ideal setting in\nwhich the robots have perfect motion control and synchrony More importantly, our results may form the foundation for theoretical work on more\nrealistic models of swarm robotics in the continuum, with asynchronous motion, sensor errors, slippage, and hardware failures",
    "More importantly, our results may form the foundation for theoretical work on more\nrealistic models of swarm robotics in the continuum, with asynchronous motion, sensor errors, slippage, and hardware failures 4 Hsiang et al 1 2 Prior and Related Work\n\n\nThere has been considerable study recently of distributed control and coordination of a set of autonomous robots Gage [14,15] has proposed the development of command and control tools for arbitrarily large swarms of microrobots and has proposed coverage paradigms in the context of robot dispersal\nin an environment Payton et al [20,21] propose the notion of “pheromone\nrobotics” for world-embedded computation Payton et al [20,21] propose the notion of “pheromone\nrobotics” for world-embedded computation Wagner et al Wagner et al [9,27,28,29] developed multi-robot algorithms, directly inspired by ant behaviors, for searching\nand covering Principe et al [13,22] and Suzuki et al [12,25,26] have studied\nalgorithmic aspects of pattern formation in distributed autonomous robotics\nunder various models of robots with minimal capabilities The related flocking\nproblem, which requires that a set of robots follow a leader while maintaining a formation, has been studied in several recent papers; see, e The related flocking\nproblem, which requires that a set of robots follow a leader while maintaining a formation, has been studied in several recent papers; see, e g , [3,6,16] Balch [2] has developed “Teambots”, a Java-based general-purpose multirobot simulator There is a vast literature on algorithms for one or several robots to explore unknown environments The environments can be modeled as graphs\n(directed or undirected), mazes, or geometric domains, and the robots can\nhave a range of computing powers; see, e",
    "The environments can be modeled as graphs\n(directed or undirected), mazes, or geometric domains, and the robots can\nhave a range of computing powers; see, e g , [1,7,8,10,11] , [1,7,8,10,11] Mitchell [19] includes a survey of many results on exploring and navigating in geometric\nenvironments Dispersion algorithms have been recently studied both in the context of\nmulti-robot coverage and sensor network deployment; see [4,5,17,30] Methods\ninclude potential fields [17,23], “artifical physics” [24], attraction-repulsion [18],\nand algorithms based on molecular dynamics [5] While these studies have examined empirically the merits of heuristics, they have not addressed formally\nthe algorithmic efficiency of the dispersion problem 2 Preliminaries\n\n\nFor an arbitrary connected region R in the plane, we let R denote the set\nof pixels that lie entirely within R A pixel is an axis-aligned unit square,\n{(x, y) : i ≤ x ≤ i + 1, j ≤ y ≤ j + 1}, whose lower left corner is given by\nthe integer grid point (i, j) Two pixels are neighbors if they share a common\nedge; thus, pixel (i, j) has four neighbors, (i − 1, j), (i + 1, j), (i, j − 1),\nand (i, j + 1) We refer to R as the environment, and we assume that it is\nconnected A subset, D ⊂ R, of the pixels are doors, which serve as sources\nof incoming robots See Figure 1(right) A robot r is said to occupy a pixel p = (i, j) when it is located in that\npixel We assume that at most one robot can occupy any one pixel at any\ngiven time t We let p(r, t) denote the pixel occupied by robot r at time t We\nlet prev(r, t) = p(r, t − 1) denote the pixel previously occupied by robot r Rapidly Dispersing Robot Swarms 5\n\n\nTime is discretized into steps t = 0, 1, 2, 3, The positions of the robots\nat time t are given by the set S(t), where D ⊆ S(t) ⊆ R At time 0, there is\none robot in each door: S(0) = D Each pixel is in one of three states at time t: (1) the pixel is an obstacle if\nit does not lie in R; (2) the pixel is occupied if it is in R and a robot occupies\nit; or (3) the pixel is unoccupied if it is in R and no robot occupies it at time\nt An unoccupied pixel at time t is classified as either previously occupied, if\nit was occupied by some robot at some time prior to t, or frontier, if it has\nnever been occupied Robots have sensors that detect information about the local environment In particular, if a robot occupies pixel (i, j) at time t, then we assume that\nit can detect the state of each pixel within a distance r S of (i, j), where r S\nis the (fixed) sensor radius Robots have no global sensor (e g , a GPS) and\nno knowledge of the coordinates of the pixels they occupy We assume that each robot has a small finite memory that allows it to\nremember the sensor readings of the last T ≥ 1 time steps; i e , a robot\nknows the sensor readings it has taken at time t − T, t − T + 1, , t − 1, t",
    ", t − 1, t In\nparticular, each robot knows which nearby pixels have been occupied recently\nby other robots The algorithms in this paper have an O(1)-bit memory; thus,\nthe robots have the computational power of finite automata We assume that robots have a limited ability to communicate with nearby\nrobots In particular, at any given time step a robot is able to exchange a\nconstant-size message with any robot that lies within a prescribed communication radius, r C, of the robot The communication graph, G(t), of the\nswarm S(t) at time t is defined to be the undirected graph whose nodes are\nthe robots S(t) and whose edges link pairs of robots that communicate The\nswarm is said to be connected at time t if each connected component of G(t)\ncontains at least one door pixel Robots move discretely on the grid of pixels If at time t a robot occupies\npixel (i, j) of R, and a neighboring pixel (say, (i + 1, j) ) of R is unoccupied\nat time t, then the robot may take a step to the right, so that at time t + 1\nit occupies pixel (i + 1, j) Naturally, no two robots can move into the same\npixel, since no pixel can be occupied by more than one robot Thus, if two\nrobots are occupying pixels that neighbor an empty pixel p of R, then the\nrobots must negotiate which one of them will have the right of way to enter\np A simple way to handle this negotiation is to establish a priority among\nthe four directions, e g , north, south, east, west The robot occupying the\npixel with the highest priority with respect to p has first rights for moving\nto p The above rules on occupying and vacating pixels force a constant delay\nin the motion Suppose that robot r occupies pixel (i, j) at time t and vacates\n(i, j) at time t +1 No other robot r [′] can occupy pixel (i, j) during time t +1;\nthe earliest possible time that the pixel can be occupied is t + 2 In principal,\nwe could vary these local rules For example, we could allow robot r [′] to enter\n\n\n6 Hsiang et al pixel (i, j) at timestep t + 1, if it enters in one direction while the current\nrobot r leaves in the opposite direction However, these rules would require\na much higher degree of coordination among the robots, and the movement\ndecisions of robots would have to be less local Specifically, whether a given\nrobot can enter one pixel may depend on whether a different robot far away\nleaves another pixel Alternatively, we could build a longer delay into the\nmovement rules, but the resulting filling algorithms would be essentially the\nsame Note that the delay has an immediate impact on the necessary sensor\nrange: If we require a delay of two time steps, robots need at least a sensor\nrange of two, in order to be able to keep track of predecessors and successors A similar issue arises in the way new robots enter through the door For\nsimplicity, we assume that a door pixel is always occupied by a robot; as soon\nas the robot occupying a door pixel moves to an adjacent pixel, a new robot\nmaterializes at the door One can consider there to be an infinite supply of\nrobots on the “other side” of a door pixel, so that a new robot steps into the\ndoor whenever the robot that was there previously moves to another pixel of\nR When a robot first appears at the door, we assume that the robot points\nnorth We say that the robots have filled the region R at time t if S(t) = R; in\nthis case, the robots are well dispersed A strategy is a set of rules by which\nrobots move, basing their movement decisions solely on the constant amount\nof information they sense and remember The makespan of a strategy is the\nminimum time, t [∗], until the robots have filled the region R 3 Dispersion Strategies for a Single Door\n\n\nWe begin with the case of a single door pixel s, which we call the source We\ndescribe strategies based on the notion of “leaders” and “followers” A robot r at time t at position p(r, t) is classified as moving (meaning that\nit is “active”) or stopped (meaning that it no longer moves) If r is moving,\nit is classified as either a leader or a follower In our leader-follower strategies, each robot r at time t has a successor\nrobot, succ(r, t), that is following r and a predecessor robot, pred(r, t), that\nis leading r If robot r is at the door at time t (p(r, t) = s), then we define\nsucc(r, t) to be NIL; if r is a leader, then we define pred(r, t) to be NIL At time t = 0 there is a robot at the door s, which is designated as moving\nand as a leader 3 1 Depth-First Leader-Follower\n\n\nThe depth-first leader-follower strategy (DFLF) is inspired by depth-first\nsearch in a graph Specifically, at any given time t ∈{0, 1, 2, 3, }, there is\nexactly one leader, r, which is on pixel p(r, t) and r is looking for a frontier\npixel (one that has never been occupied by a robot) (Thus, necessarily the\n\n\nRapidly Dispersing Robot Swarms 7\n\n\npixel from which the robot came, prev(r, t), is not frontier at time t ) If there\nare two or more frontier pixels neighboring p(r, t), the leader selects any one\nof them as its next destination If the leader has no frontier pixel next to it, it stops (its state changes\nto “stopped”), and it tells its successor, succ(r), to assume the leadership\n(succ(r)’s state changes to “leader”) at the conclusion of this time step (The\npredecessor completes its move before taking over the leadership ) If the\nleader has no predecessor (i e , it is a robot at the door), then the algorithm\nhalts (In this section, successors and (non-Nil) predecessors are invariant\nover time, and thus t is removed from the argument )\nAny robot r that is a follower (i e , not the leader) simply follows its\npredecessor: at time t it steps next to prev(pred(r), t), the pixel previously\noccupied by the predecessor of r Note that once a robot stops, it never moves\nagain Furthermore, at any point in time there is exactly one leader When dealing with finite automata, we have to use particular care when\nimplementing the leader-follower strategy As each robot has only a finite\nnumber of states, it cannot keep track of the identities of other robots, nor\ncarry its own “ID label” Instead, we use spatial information to pursue the\nimmediate predecessor Each robot r has a “heading”, indicating the direction in which it is moving The predecessor pred(r) is the nearest robot in\nthat direction Similarly, each robot keeps track of its “tailing”, the direction\nfrom which it came Thus, the successor is the nearest visible robot in that\ndirection Whenever a robot is about to change its heading, it signals this\nturn to its immediate successor Heading and tailing are updated according to delay and sensor-range This is reflected in the following lemma and\ncorollary, which are proved by introduction on time Lemma 1 If r is not the leader at time t, then prev(pred(r), t) is an unoccupied pixel neighboring p(r, t) Furthermore, the maximum (L 1 ) distance\nbetween r and pred(r) is 2 Corollary 1 If a pixel is not occupied in two consecutive time steps t and\nt +1, then it was never occupied before time t (i e , there are no “large gaps”\nof time in the occupation of a pixel )\n\n\nA further consequence of the above lemma and corollary is that the DFLF\nstrategy can be implemented with a sensor radius of r S = 2 and a memory\nof T = 1 (i e , each robot recalls its previous sensor reading)",
    ", each robot recalls its previous sensor reading) Now it is not\nhard to derive the following result:\n\n\nTheorem 1 The DFLF algorithm halts when all pixels are occupied by\nrobots The makespan of the DFLF algorithm is 2A−1, where A is the number\nof pixels of the environment R Proof At each time step there is exactly one leader and that leader will\ndo one of two things: (1) move to a frontier pixel, or (2) change its status\n\n\n8 Hsiang et al to stopped and transfer leadership to its predecessor (If the leader has no\npredecessor, that is, it is at the door, the algorithm halts ) Since each nondoor pixel can be changed from frontier to non-frontier at most once, and each\npixel can have a robot “park” itself on top of it at most once, the number of\nsteps before the algorithm halts is at most 2A − 1 The algorithm does not\nstop earlier since there is always a leader and the leader must do one of the\ntwo actions ((1) or (2)) above Note that the factor 2 is a result of using a delay of 2 It is easy to see\nthat this is best possible The total distance traveled by all robots in a filling using DFLF is at\nmost A [2], since each robot steps at most A We note that there are examples\nin which any dispersion strategy will require Ω(A [2] ) total travel One trivial\nexample is a 1 × A rectangle, with the door pixel at one end A trivial lower\nbound on the total travel for any given instance is the sum of the distances\nfrom each pixel of R to the door DFLF may use substantially more total travel than an optimal (minimum makespan) strategy that minimizes total travel; consider, for example,\na square with side lengths A [1][/][2], for which DFLF requires total travel of A [2]\n\nwhile an optimal strategy achieves total travel O(A [3][/][2] ) 3 2 Breadth-First Leader-Follower\n\n\nWe now describe an alternative dispersion algorithm, the breadth-first leaderfollower (BFLF) strategy BFLF often has advantages over the DFLF strategy\nin terms of other metrics of performance (total travel of the robots, maximum\ntravel of any one robot, total relative distance, etc), while still being optimal\nin terms of makespan (2A − 1) The BFLF strategy is substantially more complex than the DFLF, as it\nis not trivial to implement breadth-first search with local decision rules on\n(finite-automata) robots; indeed, our strategy does not perform breadth-first\nsearch, but it “approximates” breadth-first search sufficiently well to have\nsome similar properties As before, a robot can be in a “moving” state or a “stopped” state;\nhowever, we now introduce a third state, the waiting state, which is an interim\nstate when a robot pauses temporarily and waits to be able to move Once\na robot is in a stopped state, it never moves again In the BFLF strategy\nwe can have multiple leaders, while in DFLF we have only one As described\nfor DFLF, we use a limited amount of spatial information to keep track\nof successors and predecessors Other local rules are more complex and are\ndescribed in the following Initially, there is one leader robot — the robot at the door, s When a\nrobot r materializes at the door, it chooses to follow the previous robot that\nleft the door A leader always attempts to go to a neighboring frontier pixel,\nbut makes sure it does not stray too far from its follower If there are no\n\n\nRapidly Dispersing Robot Swarms 9\n\n\nneighboring frontier pixels, the leader waits for the immediate follower to\ncatch up As soon as the immediate follower catches up, the leader becomes\nstopped and passes on the leadership role to the immediate follower If the\nleader r at pixel u has a choice among neighboring frontier pixels, it picks any\none of them to be its heading If other frontier pixels adjacent to u remain\nunclaimed by other robots following different branches of dispersion, then the\nfollower r [′] of r will choose one of these pixels as its heading when it arrives at\nu; if there remains a frontier pixel adjacent to u, then r [′] ’s follower r [′′] chooses\nthis pixel as its heading when it arrives at u Here, r [′] and r [′′] are relabeled\n“leaders” and pixel u is marked as a branching point A robot r is only allowed to move at time t, if it satisfies the Movement\nCriterion (MC): A robot currently occupies prev(r, t) (its “parent” position)\nor a robot is currently heading for prev(r, t) If the MC is satisfied, the robot\nr moves to its heading; otherwise, it remains at its current position, p(r, t)\nbut is still heading for its target pixel As we will see below, a robot r is never\nblocked by its immediate predecessor except for the time step at which r first\nappears at the door or a time when its immediate predecessor is a leader with\nnowhere to go, meaning that the leadership will be passed to r The BFLF strategy tries to create as many paths as possible at all times The visited pixels form a tree that guides the directions that robots move;\nthus, pixels have parents and grandparents At branches in the tree (pixels\nwith ≥ 2 children), robots alternate the direction that they travel Specifically, when a robot r leaves a pixel at time t, it tells its immediate follower\nr [′] = succ(r, t) what r [′] ’s immediate destination should be Branching enables\nrobots arriving at the same pixel at different times to go in different directions, thereby balancing the flow Lemma 2 If not all pixels are occupied, then some robot can move The following structural lemma shows that the BFLF algorithm is nonblocking, i",
    "The following structural lemma shows that the BFLF algorithm is nonblocking, i e , a robot r is never “delayed” by its predecessors, only by its\nfollowers; i e , only the MC holds a robot back, not temporary blockages\ndownstream Correctness follows by induction on the height of the tree Lemma 3 If a robot is at pixel v and a robot is at pixel u, the non-root\nparent of v, then the robot at v is stopped Corollary 2 Corollary 2 A robot moves from the root every other time step, until all\npixels are occupied I e , if a robot did not pop up at the root at time t, then one\nmust pop up at time t + 1, unless all pixels (including the root) are occupied Lemma 4 The robots maintain a communication distance of 3, meaning\nthat the algorithm works for r S ≥ 3 The maximum L 1 -distance from a robot\nto a follower is 3 Furthermore, at least one of the following pixels is occupied\nwhen a robot is at pixel u: (1) the parent of u, (2) the grandparent of u, or\n(3) the uncle of u 10 Hsiang et al 10 Hsiang et al Putting all the claims together and using similar reasoning as for Theorem 1, we get the same kind of bound on the makespan:\n\n\nTheorem 2 The BFLF algorithm halts when all pixels are occupied by robots The makespan of the BFLF algorithm is 2A − 1, where A is the number of\npixels of the environment R 3",
    "3 3 Experimental Comparison\n\n\nWhile the DFLF and BFLF strategies both have optimal makespan, they\ndiffer with respect to other performance metrics We have implemented in\nJava a simulator for testing our dispersion strategies, while measuring various\nperformance measures, including: (1) the depth of the tree of all paths from\nthe source (i We have implemented in\nJava a simulator for testing our dispersion strategies, while measuring various\nperformance measures, including: (1) the depth of the tree of all paths from\nthe source (i e , the length of the longest path of a robot); (2) the average\ndistance traveled by a robot during the dispersion; and (3) the average of\nthe ratios, ρ i = l i /d i, of the (L 1 ) distance l i from the door to robot i’s final\nlocation to the total distance d i traveled by robot i during the dispersion We have compared the DFLF and BFLF strategies for the case of a single door, in a variety of different environments Our results show that the\naverage depth of the tree grows substantially more rapidly, as a function of\nthe number of pixels, for DFLF than it does for BFLF; e g , for an n-by-n\nsquare grid, BFLF tree depth grows linearly in n while DFLF depth grows\nclose to quadratically in n Similarly, the average distance traveled by a robot\nusing DFLF grows more rapidly than using BFLF The average of the ratios\nρ i = l i /d i decreases with increasing problem size for DFLF, while it increases\nfor BFLF Details of the experimental results are deferred to the full paper 4 Dispersion with Multiple Doors\n\n\nWe now consider the case in which there are k ≥ 1 door pixels In order to\nachieve rapid filling, the objective is to maintain a flow of robots out of as\nmany doors as possible The difficulty is that one robot chain out of one door\npixel may unnecessarily block the flow of robots out of other door pixels (See\nthe introduction and Figure 1(left) for examples )\n\n\n4",
    ")\n\n\n4 1 Laminar Flow Leader-Follower (LFLF) Algorithm\n\n\nThis section describes the Laminar Flow Leader-Follower (LFLF) algorithm The LFLF algorithm maintains rapid flows by careful use of cutting and splicing The emergent behavior of the swarm is a left-hand-on-wall strategy The\nbehavior of the algorithm is complex because bottlenecks in the environment\nmay force the flow to divide into smaller flows that fill different regions and\nmay merge and split In the LFLF algorithm there are k multiple door pixels, s 1, s 2, · · ·, s k Note that LFLF matches DFLF algorithm if k = 1 As in the k = 1 case,\n\n\nRapidly Dispersing Robot Swarms 11\n\n\nour dispersion strategies are based on leaders and followers A robot r at\ntime t at position p(r, t) is classified as active or inactive (stopped) If r is\nactive, it is either a leader or a follower However, unlike for k = 1, robots\nrevert between leaders and followers (In contrast, for k = 1 a robot changes\nroles from follower to leader but only relinquishes the leader role by stopping and becoming inactive ) Furthermore, in DFLF once a robot stops, it\nbecomes inactive In contrast, in LFLF a robot may temporarily stop while\nstill remaining active In LFLF (as in DFLF), robots have successors and predecessors, but in\nLFLF a robot’s immediate successor or predecessor may change over time Thus, each robot r at time t has a predecessor robot denoted robot-pred(r, t)\nand a successor robot denoted robot-succ(r, t) If robot r is at a door pixel at\ntime t (p(r, t) = s i, for i ∈ [1, k]), then robot-succ(r) = NIL; if r is a leader\nat time t, then robot-pred(r) = NIL Here we further refine the roles of the pixels A pixel can be: (1) an\nobstacle, (2) a frontier pixel (a pixel that has never been occupied), (3) an\ninactive pixel, that is, an (occupied) pixel that hosts an inactive robot, (4) an\nactive pixel, (which may be occupied or not) If a pixel is unoccupied but\npreviously occupied, then it is always active; if a pixel is occupied, then it is\nactive if and only if the robot it hosts is active Note that door pixels may be active or inactive, as described later Active\npixels play the role of transporting robots throughout the domain whereas\ninactive pixels are essentially obstacles Analogous to the definition of predecessor and successor robots, each active pixel has predecessor and successor\npixels In particular, pixel u at time step t has successor pixel pixel-succ(u, t)\nand predecessor pixel pixel-pred(u, t) For door pixels s i at any time t ≥ 0\npixel-succ(u, t) = NIL A leader pixel u at time t has pixel-pred(u, t) = NIL As we will see, if a\nleader pixel contains a robot, then the robot is a leader, however the leader\nrobot may not be on a leader pixel and the leader pixel may not contain\nrobots We call a chain of predecessor pixels starting from the door pixel s i\nand ending at a leader pixel, a flow line We now define formally the left side and right side of the flow To do so, we\nfirst present some intermediate definitions Consider a pixel v at time t, and\nlet u = pixel-succ(v, t) and w = pixel-pred(v, t) Let the incoming direction\nfor v at time t be the vector [−→] v u and let the outgoing direction for v at time\nt be the vector [−→] v w Consider the (vertical or horizontal) neighboring pixels, when we start\nfrom the incoming direction [−→] v u and rotate clockwise until reaching the outgoing direction [−→] v w Those neighboring pixels at intermediate (vertical or\nhorizontal) orientations are defined to be on the left-hand side of v time t Thus, the left-hand side may contain 0, 1, or 2 pixels Any neighboring pixel\nthat is not on the left-hand side, is on the right-hand side; this includes the\npixels at the incoming and outgoing directions 12 Hsiang et al Note that leader pixels do not have outgoing edges, invalidating this definition For a leader pixel, we define all neighboring pixels (except the successor\npixel) to be on the left-hand side The left side of a flow line is the union of the left sides of the non-leader\npixels in the flow line The essential idea the LFLF algorithm is to treat the left side of the flow\nline completely differently from the right side of the flow line Specifically, we\nsplice into the left-hand side but we cannot splice into the right 4 2 Splicing and the LFLF Algorithm\n\n\nSuppose that at time t a leader robot r a reaches a pixel u = p(r a, t) If u has\nan (unoccupied) predecessor pixel pixel-pred(u, t), then robot r a moves to this\npixel (Since r a is a leader robot, it will never have an occupied predecessor\npixel )\nOtherwise, pixel u = p(r a, t) is a leader pixel If u = p(r a, t) has no\nneighboring frontier pixels, then robot r a tries to pass on the leadership Robot r a first looks for a neighboring active pixel v If no such v exists,\nthen r a becomes inactive and passes the leadership to its successor robot\nrobot-succ(r a, t) When r a becomes inactive, pixel u also becomes inactive\nand its successor pixel becomes the new leader pixel If robot r a looks for a neighboring active pixel v, and such a v exists,\nthen r a checks whether u = p(r a, t) is a left-hand neighbor of v If this is not\nthe case for any possible v, then again r a becomes inactive and passes the\nleadership to its successor robot robot-succ(r a, t) As before, when r a becomes\ninactive, pixel u also becomes inactive and its successor pixel becomes the\nnew leader pixel If there exists such a v, robot r a chooses the first such v sweeping clockwise, starting from the incoming direction We redefine the predecessor pixel\npixel-pred(u, t + 1) := v and thus successor pixel pixel-succ(v, t + 1) := u Thus, the previous successor pixel of v becomes a new leader pixel (Note\nthat this new leader pixel may or may not have a robot on it ) Now r a identifies its new leader; it follows predecessor pixels starting at v until it finds\na robot r b and sets robot-pred(r a, t + 1) = r b and robot-succ(r b, t + 1) = r a Robot r a then passes the leadership to r c = robot-succ(r b, t) Rapidly Dispersing Robot Swarms 13\n\n\nFig 2 The LFLF algorithm: There are six door pixels in the lower left corner Splicing enables the flow to turn a corner 4 3 Correctness of LFLF\n\n\nWe now show that LFLF always fills an environment During LFLF, we claim\nthat the following invariant is maintained: The left side of a flow line consists\nof visited pixels and obstacles This follows from the fact that, whenever a\nrobot enters a pixel, it turns as far left as it can (left-hand-on-the-wall) The\ninvariant implies the following lemma, which we use to show that the visited\nregions propagate out from obstacle pixels:\n\n\nLemma 5 The union of boundary points separates the visited region from\nobstacles and the right side of flows In other words, the unvisited region only\ntouches a flow from its right Another useful property of flow lines is the following:\n\n\nLemma 6 Flows do not self-intersect Lemma 7 Leadership passing does not change the total number of leader\nrobots Thus, the number of leader robots at any time step t is equal to the\nnumber of active doors Theorem 3 The robots always fill environment R Proof When a robot becomes inactive, it is a leader and its surrounding\npixels must all not be frontier, for otherwise r would advance to such a pixel\nand still be active Therefore, if an active pixel u is next to a frontier pixel\nv, any robot advancing into u will not become inactive and some flow lines\ncan advance into the empty region so it will be filled In the next sections we analyze the makespan for this filling strategy 4 4 Competitive Analysis for Online Strategies\n\n\nFor any strategy S, let n S (t) be the number of robots that enter through the\ndoors during timestep t; we define n S (0) = k Note that the inherent delay of 2 in robot movement means that n S (t)\nis a highly erratic function, so that in one timestep k robots might enter\nthe doors, implying that in the next timestep no robots enter the doors 14 Hsiang et al In LFLF additional delays are caused by splicings, and therefore we cannot\neven say that a robot enters an active door pixel every other timestep To\nunderstand why, consider Figure 2 When one flow line splices into a different\nflow line, a robot may get delayed by one additional time step in order to\nobtain the required separation between robots If many splicing are happening\nnext to each other, this can cause an accumulated delay of up to k time units,\nwhich causes a “wave” of packed robots that propagates back towards the\ndoor pixels Thus, a door pixel might temporarily hold off ejecting robots for\nmany units without the door pixel becoming inactive Whenever an active\ndoor pixel does not eject a robot we say there is a door-pixel delay Fortunately, the following lemma bounds the number of splicings (and\nalso the total number of door-pixel delays) Lemma 8 A pixel can only be used to initiate O(1) splicings Theorem 4 The LFLF strategy is O(log(k + 1))-competitive Proof Consider the times {t i } [⌈] i=0 [log(][k][+1)][⌉], where t i is the latest timestep during\nwhich at least k/2 [i] door pixels are active We call times t 0, t 1, t 2, , t ⌈log(k+1)⌉\nsignificant events Consider the time interval from t i to t i+1, when at least\nk/2 [i][+1] door pixels are active Thus, the total number of robots leaving the\ndoor plus door-pixel delays during this interval is at least (k/2 [i][+1] )(t i+1 − t i ) Now consider an optimal strategy S [∗], and consider the cut χ associated\nwith the significant event t i of LFLF Cut χ is the boundary between the\noccupied and frontier pixels and has size at most k/2 [i] A lower bound on\nthe makespan of any strategy is the area “behind” χ (i e , the side of χ not\ncontaining the doors) divided by the length of χ plus the amount of time\nrequired to send the flow from the door to reach χ Thus, the makespan,\nopt, of S [∗] satisfies\n\nopt ≥ [k/][2] [i][+1] [(][t] [i][+1] [ −] [t] [i] [)] = (t i+1 − t i )/2 k/2 [i]\n\n\nSumming over all significant events we obtain that the total filling time of\nLFLF is O(opt · log(k + 1)) If we disregard the issue of delays caused by pixels having to be fully\nvacated before being re-entered, we get a whole class called sensible strategies,\ndefined by the following two conditions:\n\n\n(1) n S (t) is non-increasing in t; and\n(2) If n S (t) > n S (t + 1), then at time t the number of occupied pixels\nbordering on a frontier pixel is n S (t + 1) The above proof also implies the following; quite clearly, this result still\nholds if we extend the notion of sensible strategies to allow for some delays,\nas long as these only add a constant factor to the filling times Theorem 5 Any sensible strategy is O(log( [k] b [+ 1))][-competitive ]\n\n\nRapidly Dispersing Robot Swarms 15\n\n\n2k robots enter\n\n\nk+1 corridors (\"doors\")\nof width k\n\n\n\nk/4+1\n\ncorridors,\nwidth k/4\n\n\n\n\n\n\n\n\n\n\n\n\n\nk/2 + 1 corridors of width k/2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n_**k/4**_\n\n\n\nFig 3 Left: An environment that is hard for both depth-first and breadthfirst filling strategies This example shows that LFLF and related strategies are\nΩ(log(k + 1)) competitive Right: A scenario in which any simple-minded strategy\nis Ω(log(k + 1)) competitive 4 5 Competitive Analysis of Simple-Minded Strategies\n\n\nUnder certain natural assumptions that limit the power of strategies, it is\npossible to give matching lower bounds on the competitiveness To give some\nintuition, consider first the class of examples shown in Figure 3(left), which\nshows that the laminar flow algorithm may take as much as Ω(log(k + 1))\ntimes opt Theorem 6 The LFLF algorithm is Ω(log(k + 1))-competitive This lower bound can be generalized to a much larger class of strategies We say that strategy S is simple-minded if the following condition holds:\nThere is a constant C, such that we can only tell the number A [′] of pixels in\na region R [′] ⊆ R when a set R [′′] ⊆ R has been visited that has all pixels in R [′]\n\nwithin L 1 distance C Considering simple-minded strategies is quite natural in the context of\nrobot swarms: If we assume we only “know” a region R [′] after each pixel has\nbeen seen by one of the robots, then the constant C corresponds precisely to\nthe sensor range The example of Figure 3(left) can be generalized as shown\nschematically in Figure 3(right), which forms the basis for the proof of the\nfollowing theorem:\n\n\nTheorem 7",
    "The example of Figure 3(left) can be generalized as shown\nschematically in Figure 3(right), which forms the basis for the proof of the\nfollowing theorem:\n\n\nTheorem 7 Any simple-minded strategy is Ω(log(k + 1))-competitive A particular subclass of simple-minded strategies is one that arises quite\nnaturally in exploration problems: We say that a strategy is conservative\nif any pixel that has been “discovered”, i e , come within sensor range of a\nrobot, must stay within sensor range of some robot For a constant-size sensor\n\n\n16 Hsiang et al range, it is easy to prove the following statement, which has been claimed for\na long time in a different context:\n\n\nProposition 1 All conservative strategies are simple-minded As the LFLF strategy is conservative by design, we conclude that the\nlower bound of Theorem 7 applies to LFLF As the LFLF strategy is conservative by design, we conclude that the\nlower bound of Theorem 7 applies to LFLF Acknowledgements We thank N Jovanovic and M Sztainberg for contributions to this research This reseearch was partially supported by HRL Labs\n(a DARPA subcontract), Honda Fundamental Research Labs, NASA Ames\nResearch (NAG2-1325), NSF (CCR-0098172, EIA-0112849, CCR-0208670),\nU This reseearch was partially supported by HRL Labs\n(a DARPA subcontract), Honda Fundamental Research Labs, NASA Ames\nResearch (NAG2-1325), NSF (CCR-0098172, EIA-0112849, CCR-0208670),\nU S -Israel Binational Science Foundation, and Sandia National Labs References\n\n\n1 B Awerbuch, M Betke, R L Rivest, and M Singh Piecemeal graph exploration by a mobile robot Piecemeal graph exploration by a mobile robot In Proc 8th Annual ACM Conference on Computational Learning Theory, pages 321–328, 1995 [2 T Balch http://www teambots org ](http://www teambots org)\n3 T Balch and R C Arkin Behavior-based formation control for multi-robot\nteams IEEE Transactions on Robotics and Automation, 14(6):926–939, 1998 4 M A Batalin and G S Sukhatme",
    "Sukhatme Multi-robot dynamic coverage of a planar\nbounded environment Technical report, Robotic Embedded Systems Laboratory, University of Southern California, 2002 Technical report, Robotic Embedded Systems Laboratory, University of Southern California, 2002 5 M A Batalin and G S Sukhatme Sukhatme Spreading out: A local approach to multirobot coverage In H Asama, T Arai, T Fukuda, and T Hasegawa, editors,\nProc 6th International Symposium on Distributed Autonomous Robotic Systems, Fukuoka, Japan, 2002 Springer-Verlag 6 O B Bayazit, J -M Lien, and N M Amato Better flocking behaviors using\nrule-based roadmaps In Proc 5th International Workshop on Algorithmic\nFoundations of Robotics, 2002 5th International Workshop on Algorithmic\nFoundations of Robotics, 2002 7 M A Bender, A Fern´andez, D Ron, A Sahai, and S Vadhan The power of a\npebble: Exploring and mapping directed graphs Information and Computation,\n176:1–21, 2002 8 M A Bender and D Slonim The power of team exploration: Two robots\ncan learn unlabeled directed graphs In Proc 35th Annual Symposium on\nFoundations of Computer Science, pages 75–85, 1994 9 A M Bruckstein, C L Mallows, and I A Wagner Probabilistic pursuits on\nthe grid American Mathematical Monthly, 104(4):323–343, 1997 10 X Deng and C H Papadimitriou Exploring an unknown graph Exploring an unknown graph In Proc 31st\nAnnual Symposium on Foundations of Computer Science, pages 356–361, 1990 11 G Dudek, M Jenkin, E Milios, and D Wilkes Map validation and robot selflocation in a graph-like world Robotics and Autonomous Systems, 22(2):159–\n178, 1997 12 A Dumitrescu, I Suzuki, and M Yamashita",
    "Yamashita High speed formations of reconfigurable modular robotic systems In Proc IEEE International Conference on\nRobotics and Automation (ICRA ’02), pages 123–128, 2002 Rapidly Dispersing Robot Swarms 17\n\n\n13 P Flocchini, G Prencipe, N Santoro, and P Widmayer Distributed coordination of a set of autonomous mobile robots In Proc IEEE Intelligent Vehicle\nSymposium (IV 2000), pages 480–485, 2000 IEEE Intelligent Vehicle\nSymposium (IV 2000), pages 480–485, 2000 14 D Gage Many-robot systems http://www spawar navy mil/robots/research/manyrobo/manyrobo html 15 D Gage Sensor abstractions to support many-robot systems Sensor abstractions to support many-robot systems In Proc of SPIE\nMobile Robots VII, Boston MA, 1992, Vol 1831, pages 235–246, 1992 16 V Gervasi and G Prencipe Flocking by a set of autonomous mobile robots Technical Report TR-01-24, University of Pisa, Oct 2001 17 A Howard, M J Mataric, and G S Sukhatme Sukhatme Mobile sensor network deployment using potential fields: A distributed scalable solution to the area\ncoverage problem In H Asama, T Arai, T Fukuda, and T Hasegawa, editors, Proc 6th International Symposium on Distributed Autonomous Robotic\nSystems, Fukuoka, Japan, 2002 Springer-Verlag 18 T-R Hsiang, N Jovanovic, and M Sztainberg Dispersion Protocols for Robot\nSwarms Technical Report, Stony Brook University, 2002 Technical Report, Stony Brook University, 2002 19 J S B Mitchell, Geometric shortest paths and network optimization, In Handbook of Computational Geometry (J -R Sack and J Sack and J Urrutia, editors), pages\n633–701 Elsevier Science Publishers B V North-Holland, Amsterdam, 2000 20 D Payton, R Estkowski, M Howard Progress in Pheromone Robotics In\nProc 7th International Conference on Intelligent Autonomous Systems, 2002 21 D Payton, M Daily, R Estkowski, M Howard, C Lee Pheromone Robotics Autonomous Robots, Vol 11, No 3, pages 319-324, 2001 22 G Prencipe Distributed Coordination of a Set of Autonomous Mobile Robots Ph D thesis Dipartimento di Informatica, Universit`a degli Studi di Pisa, 2002 http://www di unipi it/phd/tesi/tesi_2002/PhDthesis_Prencipe ps gz 23 J H Reif and H Wang Social potential fields: A distributed behavioral control\nfor autonomous robots Robotics and Autonomous Systems, 27(3):171–194,\n1999 24 W Spears and D Gordon Using artificial physics to control agents In Proc IEEE Internat Conf on Information, Intelligence, and Systems, 1999 25 K Sugihara and I Suzuki Distributed algorithms for formation of geometric\npatterns with many mobile robots Journal of Robotic Systems, 13(3):127–139,\n1996 26 I Suzuki and M Yamashita Distributed anonymous mobile robots: Formation\nof geometric patterns SIAM Journal on Computing, 28(4):1347–1363, 1999 27 I Wagner and A Bruckstein Bruckstein Cooperative cleaners: a study in ant robotics Cooperative cleaners: a study in ant robotics Technical Report CIS9512, Technion, 1995 Technical Report CIS9512, Technion, 1995 28 I Wagner, M Lindenbaum, and A Bruckstein Bruckstein Distributed covering by antrobots using evaporating traces IEEE Transactions on Robotics and Automation, 15(5):918–933, 1999 29 I A Wagner, M Lindenbaum, and A M Bruckstein Bruckstein Efficiently searching a\ngraph by a smell-oriented vertex process Annals of Mathematics and Artificial\nIntelligence, 24(1-4):211–223, 1998 30 A Winfield Distributed sensing and data collection via broken ad hoc wireless connected networks of mobile robots In L E Parker, G W Bekey, and\nJ Barhen, editors, Distributed Autonomous Robotic Systems, Vol 4, pp 273–\n282, 2000 Springer-Verlag"
  ]
}